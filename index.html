<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#ffb3ba">
  <link rel="manifest" href="./manifest.json">
  <link rel="icon" type="image/png" sizes="192x192" href="./icon-192.png">
  <link rel="apple-touch-icon" href="./icon-192.png">
  <link media="all" rel="stylesheet" href="./style.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=LXGW+WenKai+Mono+TC&display=swap" rel="stylesheet">
  <title>Just One</title>
  <script src="./game.js"></script>
  <script>
    // Register service worker to clear old caches.
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js')
          .then(registration => console.log('Service Worker registered for cache cleanup'))
          .catch(err => console.log('Service Worker registration failed:', err));
      });
    }
  </script>
</head>

<body>
  <div id="app">
    <div id="mainMenu">
      <div id="langPicker">
        <label><input type="radio" name="lang" value="en" checked> English</label>
        <label><input type="radio" name="lang" value="gr"> Greek</label>
      </div>
      <div id="playerList" class="player-list-container">
        <div id="playerCount" class="player-count"></div>
        <ul id="playerListItems" class="player-list"></ul>
      </div>
      <button id="btnWord">Get Word</button>
      <button id="btnClue">Type Clue</button>
    </div>

    <div id="wordDisplay" class="hidden">
      <div id="wordText" class="fullscreenView">
        <span id="wordInner"></span>
      </div>
    </div>

    <div id="clueInput" class="hidden">
      <form id="clueForm" autocomplete="off">
        <div class="input-container">
          <input id="clueField" type="text" maxlength="30" placeholder="Enter one-word clue" pattern="[^\s]+" required>
          <button type="submit" id="submitBtn">→</button>
        </div>
      </form>
    </div>

    <div id="clueDisplay" class="hidden">
      <div id="clueText" class="fullscreenView">
        <span id="clueInner"></span>
      </div>
    </div>

    <button id="backBtn" class="hidden">←</button>
    <button id="fsBtn" title="Toggle Fullscreen">⛶</button>

    <div id="roomBadge" class="hidden"></div>
    <button id="endRoundBtn" class="hidden">End Round</button>

    <div id="roomModal" class="hidden">
      <div class="modal-content">
        <h2>Join Room</h2>
        <input type="text" id="nameInput" placeholder="Your name" maxlength="20" style="margin-bottom: 1rem;">
        <input type="text" id="roomCodeInput" placeholder="Room code (ABCD)" maxlength="4" pattern="[A-Za-z]{4}">
        <div class="modal-buttons">
          <button id="joinRoomBtn">Join Room</button>
          <button id="newRoomBtn">New Room</button>
        </div>
        <button id="offlineBtn" style="margin-top: 2rem; width: 100%; font-size: 1.3rem;">Play Offline</button>
      </div>
    </div>

    <div id="submittedWords" class="hidden">
      <h3>Submitted Words</h3>
      <div id="currentWordDisplay" class="hidden"></div>
      <ul class="word-list" id="wordsList"></ul>
      <button id="showClueBtn">Show Clue</button>
    </div>

    <div id="connectionError" class="connection-error hidden">
      <div class="error-header">
        <div class="error-title">⚠️ Connection Error</div>
        <button class="error-close" onclick="hideConnectionError()">✕</button>
      </div>
      <div id="errorMessage" class="error-message"></div>
    </div>
  </div>

  <script>
    // Dynamic text scaling function (FitText.js-like)
    function fitText(element, minFontSize = 20, maxFontSize = 300) {
      if (!element || !element.textContent.trim()) return;

      const container = element.parentElement;
      const containerWidth = container.clientWidth * 0.9;
      const containerHeight = container.clientHeight * 0.9;

      let fontSize = minFontSize;
      element.style.fontSize = fontSize + 'px';
      element.style.whiteSpace = 'nowrap';

      // Binary search for optimal font size
      let low = minFontSize;
      let high = maxFontSize;

      while (low <= high) {
        fontSize = Math.floor((low + high) / 2);
        element.style.fontSize = fontSize + 'px';

        if (element.scrollWidth <= containerWidth && element.scrollHeight <= containerHeight) {
          low = fontSize + 1;
        } else {
          high = fontSize - 1;
        }
      }

      element.style.fontSize = high + 'px';
    }

    const englishWords=["Accent", "Acorn", "Aladdin", "Alarm", "Alcatraz", "Alcohol", "Alien", "Alliance", "Amazon", "America", "Anchor", "Angel", "Anniversary", "Antarctica", "Apple", "Armstrong", "Australia", "Avatar", "Baby", "Baker", "Bald", "Ball", "Ballet", "Banana", "Band", "Bar", "Barbecue", "Barbie", "Bath", "Batman", "Battery", "Beer", "Belgium", "Bellybutton", "Belt", "Berry", "Bet", "Binoculars", "Blond", "Board", "Bone", "Bonfire", "Book", "Boss", "Bottle", "Bow", "Bowling", "Boxing", "Bracelet", "Brain", "Branch", "Bread", "Bridge", "Brush", "Bubble", "Buffy", "Burrito", "Butterfly", "Button", "Cactus", "Caesar", "Cafeteria", "Cake", "Calendar", "Canada", "Candy", "Cane", "Cannon", "Canteen", "Canvas", "Carnival", "Carousel", "Carpet", "Carton", "Cartoon", "Casino", "Castle", "Cat", "Caterpillar", "Cave", "Cavity", "Cell", "Cemetery", "Cereal", "Chain", "Champagne", "Cheddar", "Cheese", "Chewbacca", "Chicken", "Chile", "Chip", "Chocolate", "Christmas", "Churchill", "Cigarette", "Cinderella", "Cinema", "Circus", "Cleopatra", "Climb", "Clover", "Club", "Cockroach", "Cocktail", "Cocoon", "Coffee", "Colonel", "Comedy", "Comforter", "Computer", "Concert", "Cookie", "Cork", "Corner", "Cougar", "Crane", "Crepe", "Crocodile", "Croissant", "Cross", "Crossroads", "Crown", "Cube", "Cup", "Cupid", "Cycle", "Dance", "Darwin", "Decathlon", "Defense", "Dentist", "Desert", "Devil", "Diamond", "Dinosaur", "Disco", "Doctor", "Doll", "Doping", "Dracula", "Drag", "Dream", "Dune", "Dwarf", "Easter", "Egg", "Elastic", "Election", "Electricity", "Elephant", "Elf", "Elvis", "Emergency", "Emperor", "End", "Evening", "Everest", "Explosion", "Facebook", "Failure", "Fair", "Fairy", "Fall", "Farm", "Fashion", "Fever", "Fire", "Firecracker", "Fireman", "Fitzgerald", "Flame", "Flash", "Flight", "Flintstone", "Flower", "Flute", "Foam", "Ford", "Forest", "Fork", "Fountain", "Fox", "France", "Frankenstein", "Friday", "Fries", "Frost", "Fur", "Galaxy", "Game", "Gandhi", "Garden", "Garlic", "Genius", "Ghost", "Giant", "Gladiator", "Glass", "Glasses", "Goal", "Godfather", "Godzilla", "Golf", "Google", "Gothic", "Grass", "Greece", "Gremlins", "Grenade", "Grotto", "Guard", "Guillotine", "Gumbo", "Hair", "Hairdresser", "Halloween", "Hammer", "Handle", "Hanukkah", "Hat", "Hazelnut", "Heart", "Heel", "Helicopter", "Helmet", "History", "Hockey", "Hole", "Hollywood", "Honey", "Hose", "Hotel", "House", "Hulk", "Human", "Humor", "Hunter", "Ice", "Ikea", "Iris", "Iron", "Island", "Israel", "Italy", "Jackson", "Jedi", "Jewelry", "Joker", "Jones", "Jungle", "Karate", "King", "Knife", "Knight", "Ladder", "Ladybug", "Lake", "Lamp", "Language", "Large", "Lava", "Lawyer", "Leaf", "Leap", "Lego", "Letter", "Light", "Lightbulb", "Lighthouse", "Lightning", "Limb", "Lion", "Lonely", "Lottery", "Machine", "Mad", "Mafia", "Magician", "Magnet", "Manual", "Manure", "Map", "Mario", "Market", "Marriage", "Mars", "Mask", "Matrix", "Melon", "Metal", "Mexico", "Mickey", "Microsoft", "Milk", "Mill", "Mirage", "Mirror", "Missile", "Monkey", "Monopoly", "Moon", "Moscow", "Mosquito", "Mountain", "Mouse", "Mouth", "Mower", "Mozart", "Mummy", "Muse", "Mushroom", "Music", "Musketeer", "Mustache", "Mustard", "Myth", "Nail", "Necklace", "Needle", "Neighborhood", "Nest", "New", "Newspaper", "Nile", "Ninja", "Nintendo", "Noodle", "Nuclear", "Number", "Nun", "Oasis", "Octopus", "Olympics", "Opera", "Operation", "Oprah", "Orange", "Oven", "Painting", "Pair", "Palace", "Pan", "Panda", "Parachute", "Paradise", "Parrot", "Passion", "Peace", "Peach", "Peanut", "Pear", "Pebble", "Penguin", "Pepper", "Perfume", "Picasso", "Pie", "Pig", "Pigeon", "Pikachu", "Pillow", "Pilot", "Pimento", "Pipe", "Pirate", "Pit", "Pizza", "Plane", "Plastic", "Playstation", "Plier", "Poison", "Poker", "Polar", "Pole", "Police", "Pony", "Pool", "Pope", "Porcelain", "Potato", "Potter", "Powder", "Pregnant", "President", "Primary", "Princess", "Prison", "Prom", "Psycho", "Pump", "Punk", "Puppet", "Purse", "Pyramid", "Radio", "Rail", "Rain", "Rake", "Ram", "Rambo", "Ramses", "Rap", "Rat", "Ray", "Reggae", "Register", "Revolution", "Ring", "Ripe", "River", "Robot", "Rock", "Rocky", "Room", "Rooster", "Root", "Rope", "Rose", "Ruler", "Rum", "Safari", "Safe", "Sahara", "Sail", "Salt", "Sand", "Sausage", "Scale", "Scene", "School", "Screw", "Series", "Sewer", "Shack", "Shakespeare", "Shark", "Sheep", "Shelf", "Shell", "Sherlock", "Ship", "Shovel", "Shower", "Shrek", "Shrimp", "Simpson", "Siren", "Ski", "Sleeve", "Slipper", "Smoke", "Snake", "Snow", "Soap", "Sock", "Socket", "Sofa", "Sombrero", "Song", "Spartacus", "Spear", "Spice", "Spielberg", "Spy", "Stallion", "Star", "Starbucks", "Stark", "Station", "Stew", "Sting", "Stone", "Straw", "Strawberry", "String", "Study", "Stuffing", "Subway", "Sugar", "Sun", "Switzerland", "Sword", "Syrup", "Tango", "Tarantino", "Tarzan", "Tattoo", "Taxi", "Temple", "Tennis", "Terminator", "Theater", "Thought", "Thread", "Throat", "Thunder", "Ticket", "Tie", "Tiger", "Titanic", "Tobacco", "Tokyo", "Tolkien", "Tomato", "Tool", "Tornado", "Towel", "Tower", "Tradition", "Train", "Treasure", "Triangle", "Troy", "Truce", "Tube", "Tulip", "Tuna", "Tunnel", "Umbrella", "Unicorn", "Uniform", "Vacation", "Vampire", "Vegas", "Vegetable", "Vengeance", "Venus", "Viking", "Violin", "Virus", "Volcano", "Waltz", "War", "Watch", "Wave", "Weather", "Western", "Wheat", "White", "Widowmaker", "Wind", "Window", "Wine", "Wolf", "Yellow", "Zeus", "Zombie", "Zoo"];

    const greekWords= [ "Προφορά", "Βελανίδι", "Αλαντίν", "Συναγερμός", "Αλκατράζ", "Αλκοόλ", "Εξωγήινος", "Συμμαχία", "Αμαζόνιος", "Ελλάδα", "Άγκυρα", "Άγγελος", "Επέτειος", "Ανταρκτική", "Μήλο", "Armstrong", "Αυστραλία", "Avatar", "Μωρό", "Αρτοποιός", "Φαλακρός", "Μπάλα", "Μπαλέτο", "Μπανάνα", "Συγκρότημα", "Μπαρ", "Μπάρμπεκιου", "Μπάρμπι", "Μπάνιο", "Μπάτμαν", "Μπαταρία", "Μπύρα", "Βέλγιο", "Αφαλός", "Ζώνη", "Βατόμουρο", "Στοίχημα", "Κυάλια", "Ξανθός", "Σανίδα", "Κόκκαλο", "Φωτιά", "Βιβλίο", "Αφεντικό", "Μπουκάλι", "Φιόγκος", "Μπόουλινγκ", "Μποξ", "Βραχιόλι", "Εγκέφαλος", "Κλαδί", "Ψωμί", "Γέφυρα", "Βούρτσα", "Φούσκα", "Βουγιουκλάκη", "Φασόλια", "Πεταλούδα", "Κουμπί", "Κάκτος", "Καίσαρας", "Καφετέρια", "Τούρτα", "Ημερολόγιο", "Καναδάς", "Καραμέλα", "Μπαστούνι", "Κανόνι", "Καντίνα", "Καμβάς", "Καρναβάλι", "Συγκρουόμενα", "Χαλί", "Χαρτόνι", "Καρτούν", "Καζίνο", "Κάστρο", "Γάτα", "Σαρανταποδαρούσα", "Σπηλιά", "Κουφάλα", "Κελί", "Νεκροταφείο", "Δημητριακά", "Αλυσίδα", "Σαμπάνια", "Τσένταρ", "Τυρί", "Chewbacca", "Κοτόπουλο", "Ιταλία", "Πατατάκι", "Σοκολάτα", "Χριστούγεννα", "Παπανδρέου", "Τσιγάρο", "Σταχτομπούτα", "Κινηματογράφος", "Τσίρκο", "Κλεοπάτρα", "Αναρρίχηση", "Τριφύλλι", "Ρόπαλο", "Κατσαρίδα", "Κοκτέιλ", "Κουκούλι", "Καφές", "Συνταγματάρχης", "Κωμωδία", "Πάπλωμα", "Υπολογιστής", "Συναυλία", "Μπισκότο", "Φελλός", "Γωνία", "Cougar", "Γερανός", "Κρέπα", "Κροκόδειλος", "Κρουασάν", "Σταυρός", "Σταυροδρόμι", "Κορώνα", "Κύβος", "Κούπα", "Έρως", "Κύκλος", "Χορός", "Δαρβίνος", "Δέκαθλο", "Άμυνα", "Οδοντίατρος", "Έρημος", "Διάβολος", "Διαμάντι", "Δεινόσαυρος", "Ντίσκο", "Γιατρός", "Κούκλα", "Doping", "Δράκουλας", "Drag", "Όνειρο", "Dune", "Νάνος", "Πάσχα", "Αυγό", "Ελαστικός", "Εκλογές", "Ηλεκτρισμός", "Ελέφαντας", "Ξωτικό", "Elvis", "Emergency", "Αυτοκράτορας", "Τέλος", "Απόγευμα", "Έβερεστ", "Έκρηξη", "Facebook", "Αποτυχία", "Πανηγύρι", "Νεράιδα", "Φθινόπωρο", "Χωράφι", "Μόδα", "Πυρετός", "Φωτιά", "Πυροτέχνημα", "Πυροσβέστης", "Fitzgerald", "Φλόγα", "Αστραπή", "Πτήση", "Flintstone", "Λουλούδι", "Φλάουτο", "Αφρός", "Ford", "Δάσος", "Πηρούνι", "Σιντριβάνι", "Αλεπού", "Γαλλία", "Φρανκενστάιν", "Παρασκευή", "Πατάτες", "Παγωνιά", "Γούνα", "Γαλαξίας", "Παιχνίδι", "Γκάντι", "Κήπος", "Σκόρδο", "Ιδιοφυΐα", "Φάντασμα", "Γίγαντας", "Μονομάχος", "Γυαλί", "Γυαλιά", "Στόχος", "Νονός", "Γκοτζίλα", "Γκολφ", "Google", "Gothic", "Γρασίδι", "Ελλάδα", "Gremlins", "Χειροβομβίδα", "Κιόσκι", "Φρουρός", "Γκιλοτίνα", "Gumbo", "Μαλλιά", "Κομμωτής", "Απόκριες", "Σφυρί", "Χερούλι", "Hanukkah", "Καπέλο", "Φουντούκι", "Καρδιά", "Φτέρνα", "Ελικόπτερο", "Κράνος", "Ιστορία", "Χόκει", "Τρύπα", "Χόλιγουντ", "Μέλι", "Λάστιχο", "Ξενοδοχείο", "Σπίτι", "Χουλκ", "Άνθρωπος", "Χιούμορ", "Κυνηγός", "Πάγος", "ΙΚΕΑ", "Ίριδα", "Σίδερο", "Νησί", "Ισραήλ", "Ιταλία", "Τζάκσον", "Τζεντάι", "Κοσμήματα", "Τζόκερ", "Καραγκιόζης", "Ζούγκλα", "Καράτε", "Βασιλιάς", "Μαχαίρι", "Ιππότης", "Σκάλα", "Πασχαλίτσα", "Λίμνη", "Λυχνάρι", "Γλώσσα", "Μεγάλος", "Λάβα", "Δικηγόρος", "Φύλλο", "Άλμα", "Λέγκο", "Γράμμα", "Φως", "Γλόμπος", "Φάρος", "Κεραυνός", "Άκρο", "Λιοντάρι", "Μόνος", "Λαχειοφόρος", "Μηχανή", "Τρελός", "Μαφία", "Μάγος", "Μαγνήτης", "Εγχειρίδιο", "Κοπριά", "Χάρτης", "Μάριο", "Αγορά", "Γάμος", "Άρης", "Μάσκα", "Μάτριξ", "Πεπόνι", "Μέταλλο", "Μεξικό", "Μίκι", "Microsoft", "Γάλα", "Μύλος", "Οφθαλμαπάτη", "Καθρέφτης", "Πύραυλος", "Μαΐμού", "Μονόπολη", "Φεγγάρι", "Μόσχα", "Κουνούπι", "Βουνό", "Ποντίκι", "Στόμα", "Χορτοκοπτικό", "Μότσαρτ", "Μούμια", "Μούσα", "Μανιτάρι", "Μουσική", "Σωματοφύλακας", "Μουστάκι", "Μουστάρδα", "Μύθος", "Νύχι", "Κολιέ", "Βελόνα", "Γειτονιά", "Φωλιά", "Νέος", "Εφημερίδα", "Νείλος", "Νίντζα", "Nintendo", "Νούντλ", "Πυρηνικός", "Αριθμός", "Καλόγρια", "Όαση", "Χταπόδι", "Ολυμπιακοί", "Όπερα", "Επέμβαση", "Όπρα", "Πορτοκάλι", "Φούρνος", "Πίνακας", "Ζευγάρι", "Παλάτι", "Τηγάνι", "Πάντα", "Αλεξίπτωτο", "Παράδεισος", "Παπαγάλος", "Πάθος", "Ειρήνη", "Ροδάκινο", "Φυστίκι", "Αχλάδι", "Βότσαλο", "Πιγκουΐνος", "Πιπέρι", "Άρωμα", "Πικάσο", "Πίτα", "Γουρούνι", "Περιστέρι", "Πίκατσου", "Μαξιλάρι", "Πιλότος", "Πιπεριά", "Σωλήνας", "Πειρατής", "Λάκκος", "Πίτσα", "Αεροπλάνο", "Πλαστικό", "Playstation", "Τανάλια", "Δηλητήριο", "Πόκερ", "Πολικός", "Πόλος", "Αστυνομία", "Πόνι", "Πισίνα", "Πάπας", "Πορσελάνη", "Πατάτα", "Πότερ", "Σκόνη", "Έγκυος", "Πρόεδρος", "Πρώτος", "Πριγκίπισσα", "Φυλακή", "Πανηγύρι", "Ψυχασθενής", "Αντλία", "Πανκ", "Μαριονέτα", "Τσάντα", "Πυραμίδα", "Ράδιο", "Σιδηρόδρομος", "Βροχή", "Τσουγκράνα", "Κριάρι", "Ράμπο", "Ραμσής", "Ραπ", "Αρουραίος", "Ακτίνα", "Ρέγκε", "Ταμείο", "Επανάσταση", "Δαχτυλίδι", "Ώριμος", "Ποτάμι", "Ρομπότ", "Πέτρα", "Ρόκι", "Δωμάτιο", "Κόκορας", "Ρίζα", "Σχοινί", "Τριαντάφυλλο", "Χάρακας", "Ρούμι", "Σαφάρι", "Χρηματοκιβώτιο", "Σαχάρα", "Sail", "Salt", "Sand", "Sausage", "Scale", "Scene", "School", "Screw", "Series", "Sewer", "Shack", "Shakespeare", "Shark", "Sheep", "Shelf", "Shell", "Sherlock", "Ship", "Shovel", "Shower", "Shrek", "Shrimp", "Simpson", "Siren", "Ski", "Sleeve", "Slipper", "Smoke", "Snake", "Snow", "Soap", "Sock", "Socket", "Sofa", "Sombrero", "Song", "Spartacus", "Spear", "Spice", "Spielberg", "Spy", "Stallion", "Star", "Starbucks", "Stark", "Station", "Stew", "Sting", "Stone", "Straw", "Strawberry", "String", "Study", "Stuffing", "Subway", "Sugar", "Sun", "Switzerland", "Sword", "Syrup", "Tango", "Tarantino", "Tarzan", "Tattoo", "Taxi", "Temple", "Tennis", "Terminator", "Theater", "Thought", "Thread", "Throat", "Thunder", "Ticket", "Tie", "Tiger", "Titanic", "Tobacco", "Tokyo", "Tolkien", "Tomato", "Tool", "Tornado", "Towel", "Tower", "Tradition", "Train", "Treasure", "Triangle", "Troy", "Truce", "Tube", "Tulip", "Tuna", "Tunnel", "Umbrella", "Unicorn", "Uniform", "Vacation", "Vampire", "Vegas", "Vegetable", "Vengeance", "Venus", "Viking", "Violin", "Virus", "Volcano", "Waltz", "War", "Watch", "Wave", "Weather", "Western", "Wheat", "White", "Widowmaker", "Wind", "Window", "Wine", "Wolf", "Yellow", "Zeus", "Zombie", "Zoo" ]

    // Seeded random number generator using mulberry32.
    function seededRandom(seed) {
      let state = seed;
      return function() {
        state = (state * 1664525 + 1013904223) >>> 0;
        let t = state;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    // Convert string seed to numeric value.
    function stringToSeed(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32-bit integer.
      }
      return Math.abs(hash);
    }

    // Fisher-Yates shuffle with seeded random.
    function shuffleArray(array, seed) {
      const arr = [...array]; // Copy array to avoid mutation.
      const random = seededRandom(seed);

      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }

      return arr;
    }

    const mainMenu = document.getElementById('mainMenu');
    const wordDisplay = document.getElementById('wordDisplay');
    const clueInput = document.getElementById('clueInput');
    const clueDisplay = document.getElementById('clueDisplay');
    const backBtn = document.getElementById('backBtn');
    const fsBtn = document.getElementById('fsBtn');
    const wordInner = document.getElementById('wordInner');
    const clueInner = document.getElementById('clueInner');
    const clueField = document.getElementById('clueField');

    // Use unified GameState from game.js
    const state = window.GameState;

    // Language picker
    document.querySelectorAll('[name="lang"]').forEach(radio => {
      radio.addEventListener('change', e => {
        state.game.language = e.target.value;
      });
    });

    // Maximum Levenshtein distance to consider (configurable)
    const MAX_DISTANCE = 2;

    // Calculate Levenshtein distance between two strings (case-insensitive)
    // Returns distance up to MAX_DISTANCE, or Infinity if distance > MAX_DISTANCE
    function levenshteinDistance(string_a, string_b) {
      const a = string_a.toLowerCase();
      const b = string_b.toLowerCase();

      if (a.length === 0) return b.length > MAX_DISTANCE ? Infinity : b.length;
      if (b.length === 0) return a.length > MAX_DISTANCE ? Infinity : a.length;

      // Early exit if length difference > MAX_DISTANCE
      if (Math.abs(a.length - b.length) > MAX_DISTANCE) return Infinity;

      const matrix = [];

      // Initialize the first column (up to MAX_DISTANCE)
      for (let i = 0; i <= b.length; i++) {
        matrix[i] = [Math.min(i, MAX_DISTANCE + 1)];
      }

      // Initialize the first row (up to MAX_DISTANCE)
      for (let j = 0; j <= a.length; j++) {
        matrix[0][j] = Math.min(j, MAX_DISTANCE + 1);
      }

      // Calculate distances with early termination
      for (let i = 1; i <= b.length; i++) {
        let rowMin = Infinity;
        for (let j = 1; j <= a.length; j++) {
          if (b.charAt(i - 1) === a.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(
              matrix[i - 1][j - 1] + 1, // substitution
              matrix[i][j - 1] + 1,     // insertion
              matrix[i - 1][j] + 1      // deletion
            );
          }

          // Cap at MAX_DISTANCE + 1 (anything > MAX_DISTANCE is treated as infinity)
          if (matrix[i][j] > MAX_DISTANCE) {
            matrix[i][j] = MAX_DISTANCE + 1;
          }

          rowMin = Math.min(rowMin, matrix[i][j]);
        }

        // Early termination: if entire row > MAX_DISTANCE, result will be > MAX_DISTANCE
        if (rowMin > MAX_DISTANCE) {
          return Infinity;
        }
      }

      const distance = matrix[b.length][a.length];
      return distance > MAX_DISTANCE ? Infinity : distance;
    }


    // Generate room code
    function generateRoomCode() {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      let code = '';
      for (let i = 0; i < 4; i++) {
        code += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return code;
    }


    // Room management
    const roomBadge = document.getElementById('roomBadge');
    const roomModal = document.getElementById('roomModal');
    const roomCodeInput = document.getElementById('roomCodeInput');
    const nameInput = document.getElementById('nameInput');
    const submittedWordsDiv = document.getElementById('submittedWords');
    const wordsList = document.getElementById('wordsList');
    const currentWordDisplay = document.getElementById('currentWordDisplay');
    const endRoundBtn = document.getElementById('endRoundBtn');

    // Track unique players who have joined (store as Map of id -> username)
    const activePlayers = new Map();

    // Initialize button visibility on load
    updateButtonVisibility();

    // Show room modal on load
    setTimeout(() => {
      // Load saved name from localStorage
      const savedName = localStorage.getItem('justone-username');
      if (savedName) {
        nameInput.value = savedName;
      }

      roomModal.classList.remove('hidden');
      // Focus on name input if empty, otherwise on room code
      if (!nameInput.value) {
        nameInput.focus();
      } else {
        roomCodeInput.focus();
      }
    }, 100);

    // Room badge click handler
    roomBadge.addEventListener('click', () => {
      if (state.network.roomCode) {
        navigator.clipboard.writeText(state.network.roomCode).then(() => {
          const originalText = roomBadge.textContent;
          roomBadge.textContent = 'Copied!';
          setTimeout(() => {
            roomBadge.textContent = originalText;
          }, 1500);
        });
      }
    });

    // Join room button
    document.getElementById('joinRoomBtn').addEventListener('click', () => {
      const name = nameInput.value.trim();
      const code = roomCodeInput.value.toUpperCase();

      if (!name) {
        alert('Please enter your name');
        nameInput.focus();
        return;
      }

      if (!code || !/^[A-Z]{4}$/.test(code)) {
        alert('Please enter a valid 4-letter room code');
        roomCodeInput.focus();
        return;
      }

      state.network.username = name;
      localStorage.setItem('justone-username', name);
      connectToRoom(code);
    });

    // Handle Enter key in room code input
    roomCodeInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        document.getElementById('joinRoomBtn').click();
      }
    });

    // New room button
    document.getElementById('newRoomBtn').addEventListener('click', () => {
      const name = nameInput.value.trim();

      if (!name) {
        alert('Please enter your name');
        nameInput.focus();
        return;
      }

      state.network.username = name;
      localStorage.setItem('justone-username', name);
      const code = generateRoomCode();
      roomCodeInput.value = code;
      connectToRoom(code);
    });

    // Offline mode button
    document.getElementById('offlineBtn').addEventListener('click', () => {
      state.network.status = "OFFLINE";
      roomModal.classList.add('hidden');
      // Don't show the room badge in offline mode
      roomBadge.classList.add('hidden');
      // Clear player list in offline mode
      activePlayers.clear();
      updatePlayerCount();
      // Update button visibility for offline mode
      updateButtonVisibility();
    });

    // Connect to room
    function connectToRoom(code) {
      state.network.roomCode = code;
      roomBadge.textContent = `Room: ${code}`;
      roomBadge.classList.remove('hidden');
      roomModal.classList.add('hidden');

      // Connect to Gweet
      connectToGweet();

      // Send playerJoined message after connection is established
      setTimeout(() => {
        sendGweetMessage({
          type: 'playerJoined'
        });
      }, 500);
    }

    // Gweet connection management
    async function connectToGweet() {
      // Skip in offline mode
      if (state.isOffline()) return;

      // Disconnect existing connection
      if (state.network.controller) {
        state.network.controller.abort();
      }

      const channelKey = `justone-stavros-${state.network.roomCode.toLowerCase()}`;
      state.network.controller = new AbortController();

      try {
        // Fetch historical messages
        const historyResponse = await fetch(`https://gweet.stavros.io/stream/${channelKey}/?latest=50`);

        if (!historyResponse.ok) {
          throw new Error(`Failed to fetch messages: ${historyResponse.status} ${historyResponse.statusText}`);
        }

        const historyData = await historyResponse.json();

        // Process historical messages
        const tenMinutesAgo = new Date(Date.now() - 10 * 60 * 1000);
        if (historyData.messages) {
          // First pass: Find the highest wordIndex from all recent messages.
          let maxWordIndex = state.game.wordIndex;
          for (let i = 0; i < historyData.messages.length; i++) {
            const msg = historyData.messages[i];
            // Skip messages older than 10 minutes
            if (new Date(msg.created) < tenMinutesAgo) continue;

            // Check for wordIndex in newGame messages
            if (msg.values?.type?.[0] === 'newGame' && msg.values?.wordIndex?.[0]) {
              const idx = parseInt(msg.values.wordIndex[0], 10);
              if (!isNaN(idx) && idx > maxWordIndex) {
                maxWordIndex = idx;
              }
            }
          }
          // Apply the maximum word index found
          state.game.wordIndex = maxWordIndex;

          // Second pass: Find last endGame/endRound and collect playerJoined messages after it
          let lastEndIdx = -1;
          activePlayers.clear();

          for (let i = historyData.messages.length - 1; i >= 0; i--) {
            const msg = historyData.messages[i];
            // Stop looking if message is too old
            if (new Date(msg.created) < tenMinutesAgo) break;
            // Found the last endGame or endRound
            if (msg.values?.type?.[0] === 'endGame' || msg.values?.type?.[0] === 'endRound') {
              lastEndIdx = i;
              break;
            }
          }

          // Count playerJoined messages after last end
          for (let i = lastEndIdx + 1; i < historyData.messages.length; i++) {
            const msg = historyData.messages[i];
            // Skip messages older than 10 minutes
            if (new Date(msg.created) < tenMinutesAgo) continue;

            // Track playerJoined messages
            if (msg.values?.type?.[0] === 'playerJoined' && msg.values?.user?.[0]) {
              const username = msg.values?.username?.[0] || 'Anonymous';
              activePlayers.set(msg.values.user[0], username);
            }
          }

          // Update player count display
          updatePlayerCount();

          // Third pass: Process messages after last endRound for game state
          let lastEndRoundIdx = -1;
          for (let i = historyData.messages.length - 1; i >= 0; i--) {
            const msg = historyData.messages[i];
            // Stop looking if message is too old
            if (new Date(msg.created) < tenMinutesAgo) break;
            // Found the last endRound
            if (msg.values?.type?.[0] === 'endRound') {
              lastEndRoundIdx = i;
              break;
            }
          }

          // Process messages after last endRound (or all if no endRound found)
          for (let i = lastEndRoundIdx + 1; i < historyData.messages.length; i++) {
            const msg = historyData.messages[i];
            // Skip messages older than 10 minutes
            if (new Date(msg.created) < tenMinutesAgo) continue;
            handleGweetMessage(msg.values);
          }
        }

        // Establish streaming connection
        const streamResponse = await fetch(
          `https://gweet.stavros.io/stream/${channelKey}/?streaming=1`,
          { signal: state.network.controller.signal }
        );

        if (!streamResponse.ok) {
          throw new Error(`Failed to connect to stream: ${streamResponse.status} ${streamResponse.statusText}`);
        }

        // Connection successful - hide any existing errors
        hideConnectionError();

        const reader = streamResponse.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop(); // Keep incomplete line in buffer

          for (const line of lines) {
            if (line.trim()) {
              try {
                const data = JSON.parse(line);
                if (data.values) {
                  handleGweetMessage(data.values);
                }
              } catch (e) {
                console.error('Error parsing message:', e);
              }
            }
          }
        }
      } catch (error) {
        if (error.name !== 'AbortError') {
          console.error('Gweet connection error:', error);

          // Show user-friendly error message
          let errorMsg = 'Unable to connect to Gweet server. ';
          if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
            errorMsg += 'Please check your internet connection.';
          } else if (error.message.includes('404')) {
            errorMsg += 'Room not found or expired.';
          } else if (error.message.includes('500') || error.message.includes('502') || error.message.includes('503')) {
            errorMsg += 'Server is temporarily unavailable.';
          } else {
            errorMsg += 'Retrying in 5 seconds...';
          }

          showConnectionError(errorMsg, 6000);

          // Retry after 5 seconds
          setTimeout(() => {
            if (state.network.roomCode) {
              connectToGweet();
            }
          }, 5000);
        }
      }
    }

    // Error notification functions
    let errorTimeout = null;

    function showConnectionError(message, duration = 5000) {
      const errorDiv = document.getElementById('connectionError');
      const errorMessage = document.getElementById('errorMessage');

      // Clear any existing timeout
      if (errorTimeout) {
        clearTimeout(errorTimeout);
        errorTimeout = null;
      }

      errorMessage.textContent = message;
      errorDiv.classList.remove('hidden');

      // Auto-hide after duration (unless duration is 0 for persistent errors)
      if (duration > 0) {
        errorTimeout = setTimeout(() => {
          hideConnectionError();
        }, duration);
      }
    }

    function hideConnectionError() {
      const errorDiv = document.getElementById('connectionError');
      errorDiv.classList.add('hidden');

      if (errorTimeout) {
        clearTimeout(errorTimeout);
        errorTimeout = null;
      }
    }

    // Handle incoming Gweet messages
    function handleGweetMessage(data) {
      let type, word, lang, user, username, wordIndex;

      // Parse message based on format
      if (typeof data === 'object' && data !== null) {
        type = data.type?.[0];
        word = data.word?.[0];
        lang = data.lang?.[0];
        user = data.user?.[0];
        username = data.username?.[0];
        wordIndex = data.wordIndex?.[0];
      } else if (typeof data === 'string') {
        try {
          const jsonData = JSON.parse(data);
          if (jsonData.values) {
            return handleGweetMessage(jsonData.values);
          }
        } catch {
          // Parse as URL-encoded
          const params = new URLSearchParams(data);
          type = params.get('type');
          word = params.get('word');
          lang = params.get('lang');
          user = params.get('user');
          username = params.get('username');
          wordIndex = params.get('wordIndex');
        }
      }

      // Process based on message type
      if (type === 'newGame') {
        // Track the highest word index seen.
        if (wordIndex) {
          const idx = parseInt(wordIndex, 10);
          if (!isNaN(idx) && idx > state.game.wordIndex) {
            state.game.wordIndex = idx;
          }
        }
        // Set network state to IN_PROGRESS
        state.network.status = "IN_PROGRESS";

        // Set current user's role
        if (user === state.network.clientId) {
          state.network.userRole = 'wordHolder';
        } else {
          state.network.userRole = 'clueGiver';
          state.game.word = word;
          state.game.language = lang || 'en';
          // Update language selector
          document.querySelector(`[name="lang"][value="${state.game.language}"]`).checked = true;
        }

        // Reset submitted words
        state.submissions = [];
        updateSubmittedWordsDisplay();

        // Update button visibility
        updateButtonVisibility();
      } else if (type === 'submitWord' && word) {
        // Word submitted by a player
        const submission = { word, user, username: username || 'Anonymous' };
        // Check if this word hasn't been added already
        if (!state.submissions.some(s => s.word === word && s.user === user)) {
          state.submissions.push(submission);
          updateSubmittedWordsDisplay();
        }
      } else if (type === 'endRound') {
        // Round ended by another player
        handleEndRound();
      } else if (type === 'playerJoined' && user) {
        // Player joined the room
        const playerName = username || 'Anonymous';
        activePlayers.set(user, playerName);
        updatePlayerCount();
      } else if (type === 'endGame') {
        // Game ended, clear player list
        activePlayers.clear();
        updatePlayerCount();

        // Re-announce ourselves so we appear in the lobby for the next round
        setTimeout(() => {
          sendGweetMessage({
            type: 'playerJoined'
          });
        }, 100);
      }
    }

    // Send message to Gweet
    async function sendGweetMessage(message) {
      if (!state.network.roomCode || state.network.status === "OFFLINE") return;

      const channelKey = `justone-stavros-${state.network.roomCode.toLowerCase()}`;
      const params = new URLSearchParams();

      // Add user UUID to all messages
      params.append('user', state.network.clientId);

      // Add username to all messages
      if (state.network.username) {
        params.append('username', state.network.username);
      }

      // Add message fields
      for (const [key, value] of Object.entries(message)) {
        params.append(key, value);
      }

      try {
        const response = await fetch(`https://gweet.stavros.io/stream/${channelKey}/`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          body: params.toString()
        });

        if (!response.ok) {
          throw new Error(`Failed to send message: ${response.status} ${response.statusText}`);
        }

        // Hide any existing error when a message is successfully sent
        hideConnectionError();
      } catch (error) {
        console.error('Error sending message:', error);

        // Show user-friendly error message
        let errorMsg = 'Failed to send message. ';
        if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
          errorMsg += 'Please check your internet connection.';
        } else if (error.message.includes('500') || error.message.includes('502') || error.message.includes('503')) {
          errorMsg += 'Server is temporarily unavailable.';
        } else {
          errorMsg += 'Please try again.';
        }

        showConnectionError(errorMsg, 4000);
      }
    }

    // Update submitted words display
    function updateSubmittedWordsDisplay() {
      if (!state.hasSubmitted()) {
        submittedWordsDiv.classList.add('hidden');
        return;
      }

      // Show the submitted words div
      submittedWordsDiv.classList.remove('hidden');

      // Show the word display
      currentWordDisplay.classList.remove('hidden');
      currentWordDisplay.textContent = state.game.word ? `Word: ${state.game.word}` : '';

      // Clear and rebuild the list
      wordsList.innerHTML = '';

      // Get own submission for distance calculations
      const ownSubmission = state.getOwnSubmission();

      // Show own word first
      if (ownSubmission) {
        const li = document.createElement('li');
        li.textContent = `${ownSubmission.word} (You)`;
        li.className = 'own-word';
        wordsList.appendChild(li);
      }

      // Show other words with distance-based coloring
      state.submissions
        .filter(s => s.user !== state.network.clientId)
        .forEach(submission => {
          const li = document.createElement('li');
          const displayName = submission.username || 'Anonymous';
          li.textContent = `${submission.word} (${displayName})`;

          // Calculate minimum distance from this word to all other words
          let minDistance = Infinity;

          // Compare against all other submissions (including own)
          state.submissions.forEach(otherSubmission => {
            if (otherSubmission !== submission) {
              const distance = levenshteinDistance(submission.word, otherSubmission.word);
              minDistance = Math.min(minDistance, distance);
            }
          });

          // Apply appropriate class based on minimum distance
          if (minDistance <= MAX_DISTANCE) {
            li.className = `distance-${minDistance}`;
          }
          // Distance > MAX_DISTANCE gets default grey background from base .word-list li style

          wordsList.appendChild(li);
        });
    }

    // Show Clue button handler
    document.getElementById('showClueBtn').addEventListener('click', () => {
      // Hide the modal
      submittedWordsDiv.classList.add('hidden');

      // Show the clue in fullscreen
      show('clue');
      enterFullscreen();
      fitText(clueInner);
      setTimeout(() => fitText(clueInner), 100);
    });

    // Update player count display
    function updatePlayerCount() {
      const playerCountDiv = document.getElementById('playerCount');
      const playerListItems = document.getElementById('playerListItems');
      const playerListContainer = document.getElementById('playerList');
      const count = activePlayers.size;

      if (state.network.status === "OFFLINE") {
        playerListContainer.style.display = 'none';
      } else {
        playerListContainer.style.display = 'block';

        if (count === 0) {
          playerCountDiv.textContent = 'Waiting for players...';
          playerListItems.innerHTML = '';
        } else {
          playerCountDiv.textContent = `Players in lobby (${count})`;

          // Clear and rebuild the player list
          playerListItems.innerHTML = '';

          // Add each player as a list item
          activePlayers.forEach((username, userId) => {
            const li = document.createElement('li');
            li.textContent = username;

            // Mark the current user
            if (userId === state.network.clientId) {
              li.classList.add('current-player');
              li.textContent += ' (You)';
            }

            playerListItems.appendChild(li);
          });
        }
      }
    }

    // Handle ending the round (clears state and returns to menu)
    function handleEndRound() {
      // Use the GameState reset method
      state.reset();

      // Reset visual states
      wordInner.classList.remove('blurred');
      document.getElementById('wordText').classList.remove('word-blurred');
      submittedWordsDiv.classList.add('hidden');

      // Return to main menu (show() will call updateButtonVisibility)
      show('menu');
    }

    // End Round button handler
    endRoundBtn.addEventListener('click', () => {
      // Show confirmation dialog
      if (!confirm('Are you sure you want to end the round for everyone?')) {
        return;
      }

      // Send endRound message to other players
      sendGweetMessage({
        type: 'endRound'
      });

      // Handle the end round locally
      handleEndRound();
    });

    // View management
    function show(view) {
      [mainMenu, wordDisplay, clueInput, clueDisplay].forEach(v => v.classList.add('hidden'));

      if (view === 'menu') {
        backBtn.classList.add('hidden');
      } else {
        backBtn.classList.remove('hidden');
      }

      switch(view) {
        case 'menu': mainMenu.classList.remove('hidden'); break;
        case 'word': wordDisplay.classList.remove('hidden'); break;
        case 'clueIn': clueInput.classList.remove('hidden'); break;
        case 'clue': clueDisplay.classList.remove('hidden'); break;
      }
      state.view.current = view;

      // Update all button visibility based on current state
      updateButtonVisibility();

      // Update browser history for back button handling
      if (view !== 'menu') {
        history.pushState({ view: view }, '', '#' + view);
      } else {
        history.replaceState({ view: 'menu' }, '', window.location.pathname);
      }
    }

    // Auto fullscreen helper
    function enterFullscreen() {
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
      if (!isIOS && document.documentElement.requestFullscreen && !document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(() => {});
      }
    }


    // Update button visibility based on user role and game state
    function updateButtonVisibility() {
      const btnWord = document.getElementById('btnWord');
      const btnClue = document.getElementById('btnClue');

      // Simplified button state logic
      const isOffline = state.network.status === "OFFLINE";
      const isInProgress = state.network.status === "IN_PROGRESS";
      const isWordHolder = state.network.userRole === 'wordHolder';
      const isClueGiver = state.network.userRole === 'clueGiver';

      // Set button states
      btnWord.classList.toggle('disabled',
        !isOffline && isInProgress && !isWordHolder);
      btnClue.classList.toggle('disabled',
        !isOffline && (state.network.status === "ENDED" || (isInProgress && !isClueGiver)));

      // End Round button visibility
      const showEndRound = isInProgress && !isOffline &&
        (state.view.current === 'menu' || state.view.current === 'word' || state.view.current === 'clue');
      endRoundBtn.classList.toggle('hidden', !showEndRound);
    }

    // Get Word button
    document.getElementById('btnWord').onclick = () => {
      // In offline mode, always allow getting a new word
      if (state.network.status === "OFFLINE") {
        const pool = state.game.language === 'en' ? englishWords : greekWords;
        // For offline mode, just pick randomly.
        state.game.word = pool[Math.floor(Math.random() * pool.length)];

        show('word');
        enterFullscreen();

        let seconds = 2;
        wordInner.textContent = seconds;
        fitText(wordInner);
        state.game.wordDisplay = 'countdown';

        if (state.game.countdownTimer) clearInterval(state.game.countdownTimer);
        state.game.countdownTimer = setInterval(() => {
          seconds--;
          if (seconds <= 0) {
            clearInterval(state.game.countdownTimer);
            state.game.countdownTimer = null;
            wordInner.textContent = state.game.word;
            state.game.wordDisplay = 'visible';
          } else {
            wordInner.textContent = seconds;
          }
          fitText(wordInner);
        }, 1000);
        return;
      }

      // Check if user is the word holder returning to their word
      if (state.network.status === "IN_PROGRESS" && state.network.userRole === 'wordHolder') {
        // Return to the existing word
        show('word');
        enterFullscreen();
        wordInner.textContent = state.game.word;
        state.game.wordDisplay = 'visible';
        fitText(wordInner);
        return;
      }

      // Check if a game is already in progress (and user is not word holder)
      if (state.network.status === "IN_PROGRESS") {
        // Button should be disabled for clue givers
        return;
      }

      // Start a new game
      const pool = state.game.language === 'en' ? englishWords : greekWords;
      // Use room code as seed for deterministic shuffling.
      const seed = stringToSeed(state.network.roomCode.toUpperCase());
      const shuffled = shuffleArray(pool, seed);

      // Use current index, then increment for next time.
      const currentIndex = state.game.wordIndex;
      const newWord = shuffled[currentIndex % shuffled.length];
      state.game.wordIndex = currentIndex + 1;

      // Use GameState helper method
      state.startNewGame(newWord, state.game.language, 'wordHolder');
      updateSubmittedWordsDisplay();

      // Send new game message to other players
      sendGweetMessage({
        type: 'newGame',
        word: newWord,
        lang: state.game.language,
        wordIndex: state.game.wordIndex  // Send the updated index
      });

      show('word');
      enterFullscreen(); // Auto enter fullscreen

      let seconds = 2;
      wordInner.textContent = seconds;
      fitText(wordInner);
      state.game.wordDisplay = 'countdown';

      if (state.game.countdownTimer) clearInterval(state.game.countdownTimer);
      state.game.countdownTimer = setInterval(() => {
        seconds--;
        if (seconds <= 0) {
          clearInterval(state.game.countdownTimer);
          state.game.countdownTimer = null;
          wordInner.textContent = state.game.word;
          state.game.wordDisplay = 'visible';
        } else {
          wordInner.textContent = seconds;
        }
        fitText(wordInner);
      }, 1000);
    };

    // Create hold progress indicator
    const createProgressIndicator = () => {
      const indicator = document.createElement('div');
      indicator.className = 'hold-progress';
      indicator.id = 'holdProgress';

      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('viewBox', '0 0 100 100');

      // Background circle
      const bgCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      bgCircle.setAttribute('cx', '50');
      bgCircle.setAttribute('cy', '50');
      bgCircle.setAttribute('r', '40');
      bgCircle.className = 'hold-progress-background';

      // Progress circle
      const progressCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      progressCircle.setAttribute('cx', '50');
      progressCircle.setAttribute('cy', '50');
      progressCircle.setAttribute('r', '40');
      progressCircle.className = 'hold-progress-ring';
      progressCircle.id = 'holdProgressRing';

      // Set up stroke dasharray for progress animation
      const circumference = 2 * Math.PI * 40;
      progressCircle.style.strokeDasharray = `${circumference} ${circumference}`;
      progressCircle.style.strokeDashoffset = circumference;

      svg.appendChild(bgCircle);
      svg.appendChild(progressCircle);
      indicator.appendChild(svg);
      document.body.appendChild(indicator);

      return { indicator, progressCircle, circumference };
    };

    const { indicator: holdIndicator, progressCircle, circumference } = createProgressIndicator();

    // Word screen hold-to-blur functionality
    const wordText = document.getElementById('wordText');
    let holdStartTime = 0;

    // Create and play blur sound
    let audioContext = null;
    const playBlurSound = () => {
      // Create a simple beep sound using Web Audio API
      try {
        // Initialize AudioContext on first use (iOS requirement)
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        // Resume AudioContext if it's suspended (iOS requirement)
        if (audioContext.state === 'suspended') {
          audioContext.resume();
        }

        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.frequency.setValueAtTime(800, audioContext.currentTime); // 800 Hz tone
        oscillator.type = 'sine';

        gainNode.gain.setValueAtTime(1.0, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.1, audioContext.currentTime + 0.2);

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.2);
      } catch (e) {
        // Fallback: try to use a data URI for a simple beep
        try {
          const audio = new Audio("data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuE0e/cdi4HKW/A7+dV");
          audio.volume = 1.0;
          audio.play().catch(e => console.log('Audio play failed:', e));
        } catch (e2) {
          console.log('Audio playback not supported');
        }
      }
    };

    const startHold = () => {
      if (state.view.current !== 'word') {
        return;
      }

      // If currently visible, blur immediately without hold
      if (state.game.wordDisplay === 'visible') {
        state.game.wordDisplay = 'blurred';
        wordInner.classList.add('blurred');
        wordText.classList.add('word-blurred');

        // Play blur sound
        playBlurSound();

        // Haptic feedback
        if (navigator.vibrate) {
          navigator.vibrate(50);
        }
        return;
      }

      // Only require hold when unblurring (blurred -> visible)
      if (state.game.wordDisplay !== 'blurred') {
        return;
      }

      // Clean up any existing hold state
      if (state.game.holdTimer) {
        clearTimeout(state.game.holdTimer);
      }
      if (state.game.holdAnimationFrame) {
        cancelAnimationFrame(state.game.holdAnimationFrame);
      }

      state.game.isHolding = true;
      state.game.holdProgress = 0;
      holdStartTime = Date.now();

      // Show progress indicator with pulse animation
      holdIndicator.classList.add('active', 'pulse');
      setTimeout(() => holdIndicator.classList.remove('pulse'), 300);

      // Start progress animation
      const animateProgress = () => {
        if (!state.game.isHolding) return;

        const elapsed = Date.now() - holdStartTime;
        const progress = Math.min(elapsed / 500, 1); // 500ms hold duration
        state.game.holdProgress = progress * 100;

        // Update progress ring
        const offset = circumference - (progress * circumference);
        progressCircle.style.strokeDashoffset = offset;

        if (progress < 1) {
          state.game.holdAnimationFrame = requestAnimationFrame(animateProgress);
        } else {
          // Hold complete - toggle blur
          completeHold();
        }
      };

      state.game.holdAnimationFrame = requestAnimationFrame(animateProgress);

      // Set timeout as backup for completion
      state.game.holdTimer = setTimeout(() => {
        if (state.game.isHolding) {
          completeHold();
        }
      }, 500);
    };

    const cancelHold = () => {
      if (!state.game.isHolding) return;

      state.game.isHolding = false;
      state.game.holdProgress = 0;

      // Clean up timers
      if (state.game.holdTimer) {
        clearTimeout(state.game.holdTimer);
        state.game.holdTimer = null;
      }
      if (state.game.holdAnimationFrame) {
        cancelAnimationFrame(state.game.holdAnimationFrame);
        state.game.holdAnimationFrame = null;
      }

      // Hide and reset progress indicator
      holdIndicator.classList.remove('active');
      progressCircle.style.strokeDashoffset = circumference;
    };

    const completeHold = () => {
      if (!state.game.isHolding) return;

      // Unblur the word (hold is only for unblurring)
      state.game.wordDisplay = 'visible';
      wordInner.classList.remove('blurred');
      wordText.classList.remove('word-blurred');

      // Haptic feedback
      if (navigator.vibrate) {
        navigator.vibrate(50);
      }

      // Clean up
      cancelHold();
    };

    // Mouse events
    wordText.addEventListener('mousedown', (e) => {
      e.preventDefault();
      startHold();
    });

    wordText.addEventListener('mouseup', cancelHold);
    wordText.addEventListener('mouseleave', cancelHold);

    // Touch events
    wordText.addEventListener('touchstart', (e) => {
      e.preventDefault();
      startHold();
    });

    wordText.addEventListener('touchend', (e) => {
      e.preventDefault();
      cancelHold();
    });

    wordText.addEventListener('touchcancel', cancelHold);

    // Cancel hold if view changes
    const originalShow = show;
    show = (viewName) => {
      cancelHold();
      originalShow(viewName);
    };

    // Type Clue button
    document.getElementById('btnClue').onclick = () => {
      // In offline mode, always allow typing a clue
      if (state.network.status === "OFFLINE") {
        clueField.value = '';
        show('clueIn');
        // Focus the input field after the view is shown
        requestAnimationFrame(() => {
          clueField.focus();
          // For mobile devices, also scroll into view
          clueField.scrollIntoView({ behavior: 'smooth', block: 'center' });
        });
        return;
      }

      // Check if not in a game or not a clue giver
      if (state.network.status !== "IN_PROGRESS" || state.network.userRole !== 'clueGiver') {
        return;
      }

      // If user has already submitted a word, show the submitted words modal
      if (state.hasSubmitted()) {
        show('clueIn');
        updateSubmittedWordsDisplay();
      } else {
        // Show clue input for new submission
        clueField.value = '';
        show('clueIn');
        // Focus the input field after the view is shown
        requestAnimationFrame(() => {
          clueField.focus();
          // For mobile devices, also scroll into view
          clueField.scrollIntoView({ behavior: 'smooth', block: 'center' });
        });
      }
    };

    // Prevent spaces in clue field (allow all other characters including emojis)
    clueField.addEventListener('keydown', (e) => {
      // Prevent space key (keyCode 32)
      if (e.keyCode === 32) {
        e.preventDefault();
      }
    });

    clueField.addEventListener('input', (e) => {
      // Remove any spaces from the input
      e.target.value = e.target.value.replace(/\s/g, '');
    });

    // Clue form submission
    document.getElementById('clueForm').addEventListener('submit', e => {
      e.preventDefault();
      const val = clueField.value.trim();
      if (!val) return;
      if (/\s/.test(val)) { alert('One word only!'); return; }

      // In offline mode, go straight to showing the clue
      if (state.network.status === "OFFLINE") {
        clueInner.textContent = val;
        show('clue');
        enterFullscreen();
        fitText(clueInner);
        setTimeout(() => fitText(clueInner), 100);
        return;
      }

      // Check if there's a word in the channel
      if (!state.game.word) {
        alert('No word to give a clue for! Someone needs to start a new game first.');
        return;
      }

      // Send the submitted word to other players
      sendGweetMessage({
        type: 'submitWord',
        word: val
      });

      // Add to local submitted words
      state.submissions.push({ word: val, user: state.network.clientId, username: state.network.username });

      // Store the clue but don't show it yet
      clueInner.textContent = val;

      // Show the submitted words modal instead of going directly to clue display
      updateSubmittedWordsDisplay();

      // Stay in clueIn view with the modal on top
      // The modal will be shown by updateSubmittedWordsDisplay
    });

    // Handle browser back button/gesture
    function goBackToMenu() {
      // No confirmation needed since we're preserving state

      if (state.game.countdownTimer) {
        clearInterval(state.game.countdownTimer);
        state.game.countdownTimer = null;
      }

      // Reset blur state but keep the word (don't clear it)
      if (state.view.current === 'word') {
        if (state.game.wordDisplay === 'blurred') {
          state.game.wordDisplay = 'visible';
          wordInner.classList.remove('blurred');
          document.getElementById('wordText').classList.remove('word-blurred');
        }
      }

      // Hide submitted words modal when returning to menu
      submittedWordsDiv.classList.add('hidden');

      show('menu');
    }

    // Back button
    backBtn.onclick = () => {
      goBackToMenu();
    };

    // Handle browser back button/swipe navigation
    window.addEventListener('popstate', (event) => {
      // Show confirmation for word screen, always go back for other screens
      goBackToMenu();
    });

    // Event listeners for dynamic resizing
    window.addEventListener('resize', () => {
      if (state.view.current === 'word') fitText(wordInner);
      if (state.view.current === 'clue') fitText(clueInner);
    });

    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        if (state.view.current === 'word') fitText(wordInner);
        if (state.view.current === 'clue') fitText(clueInner);
      }, 100);
    });

    // Fullscreen functionality
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);

    if (!document.documentElement.requestFullscreen || isIOS) {
      fsBtn.style.display = 'none';
    } else {
      function updateFSIcon() {
        fsBtn.textContent = document.fullscreenElement ? '🗗' : '⛶';
      }
      fsBtn.addEventListener('click', () => {
        if (document.fullscreenElement) {
          document.exitFullscreen?.();
        } else {
          document.documentElement.requestFullscreen().catch(() => {});
        }
      });
      document.addEventListener('fullscreenchange', updateFSIcon);
      updateFSIcon();
    }

    // Confirmation when navigating away during active game
    window.addEventListener('beforeunload', (e) => {
      // Show confirmation if game is in progress (not in offline mode or ended state)
      if (state.network.status === "IN_PROGRESS") {
        // Cancel the event as stated by the standard
        e.preventDefault();
        // Chrome requires returnValue to be set
        e.returnValue = '';
        // Return a string for older browsers
        return 'Are you sure you want to leave? A game is currently in progress.';
      }
    });
  </script>
</body>
</html>
