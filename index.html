<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#ffb3ba">
  <link rel="manifest" href="./manifest.json">
  <link rel="icon" type="image/png" sizes="192x192" href="./icon-192.png">
  <link rel="apple-touch-icon" href="./icon-192.png">
  <title>Just One Helper</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=LXGW+WenKai+Mono+TC&display=swap" rel="stylesheet">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
      width: 100%;
      overflow: hidden;
      background: #f8f9fa;
      font-family: "LXGW WenKai Mono TC", monospace;
      -webkit-user-select: none;
      user-select: none;
      position: fixed;
      top: 0;
      left: 0;
    }

    #app {
      width: 100dvw;
      height: 100dvh;
      display: flex;
      flex-direction: column;
      position: relative;
      overflow: hidden;
    }

    .hidden { display: none !important; }

    /* Main Menu */
    #mainMenu {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 2rem;
      padding: 2rem;
    }

    #langPicker {
      display: flex;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    #langPicker label {
      font-size: 1.2rem;
      cursor: pointer;
    }

    button {
      font-family: "LXGW WenKai Mono TC", monospace;
      font-size: 1.5rem;
      padding: 1rem 2rem;
      border: none;
      border-radius: 12px;
      background: #ffb3ba;
      color: #2c3e50;
      cursor: pointer;
      transition: background 0.25s;
      touch-action: manipulation;
      min-height: 44px;
      min-width: 44px;
    }

    button:hover, button:active {
      background: #ffc9c9;
    }

    button.disabled {
      opacity: 0.5;
      pointer-events: none;
      cursor: not-allowed;
    }

    /* Fullscreen Text Views */
    .fullscreenView {
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      color: #2c3e50;
      font-family: "LXGW WenKai Mono TC", monospace;
      line-height: 1.1;
      overflow: hidden;
      position: absolute;
      top: 0;
      left: 0;
    }

    .fullscreenView span {
      display: block;
      font-size: 4rem;
      max-width: 100%;
      white-space: nowrap;
      text-overflow: ellipsis;
    }

    /* Clue Input */
    #clueInput {
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 2rem;
    }

    #clueForm {
      width: 100%;
      max-width: 500px;
    }

    .input-container {
      position: relative;
      width: 100%;
      border: 3px solid #ffb3ba;
      border-radius: 12px;
      overflow: hidden;
      background: white;
      height: 70px;
    }

    #clueField {
      font-family: "LXGW WenKai Mono TC", monospace;
      font-size: 1.5rem;
      width: 100%;
      height: 100%;
      text-align: center;
      padding: 1rem 70px 1rem 1rem;
      border: none;
      outline: none;
      background: white;
      box-sizing: border-box;
    }

    #submitBtn {
      position: absolute;
      top: 0;
      right: 0;
      font-size: 1.5rem;
      padding: 0;
      border: none;
      background: #ffb3ba;
      color: #2c3e50;
      cursor: pointer;
      transition: background 0.25s;
      border-radius: 0;
      width: 60px;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #submitBtn:hover, #submitBtn:active {
      background: #ffc9c9;
    }

    #wordInner,
    #clueInner {
      font-weight: 900;
    }

    /* Blur effect for word text */
    #wordText {
        transition: background 0.3s ease;
    }

    .blurred {
      filter: blur(60px);
      transition: filter 0.3s ease;
    }

    /* Gray background when word is blurred */
    .word-blurred {
      background: #ff9aa2;
    }

    /* Back Button */
    #backBtn {
      position: fixed;
      top: 1rem;
      left: 1rem;
      font-size: 1.5rem;
      border-radius: 50%;
      background: #ff9aa2;
      z-index: 10;
      width: 44px;
      height: 44px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #backBtn.hidden {
      display: none;
    }

    /* Fullscreen Button */
    #fsBtn {
      position: fixed;
      top: 1rem;
      right: 1rem;
      font-size: 1.5rem;
      border-radius: 50%;
      background: #ff9aa2;
      z-index: 10;
      width: 44px;
      height: 44px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Room Badge */
    #roomBadge {
      position: fixed;
      bottom: 1rem;
      left: 1rem;
      background: #ff9aa2;
      color: #2c3e50;
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-size: 1.2rem;
      font-weight: bold;
      z-index: 10;
      cursor: pointer;
      transition: background 0.25s;
    }

    #roomBadge:hover {
      background: #ffc9c9;
    }

    #roomBadge.hidden {
      display: none;
    }

    /* End Round Button */
    #endRoundBtn {
      position: fixed;
      bottom: 1rem;
      right: 1rem;
      background: #ff9aa2;
      color: #2c3e50;
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-size: 1.2rem;
      font-weight: bold;
      z-index: 10;
      cursor: pointer;
      transition: background 0.25s;
    }

    #endRoundBtn:hover {
      background: #ffc9c9;
    }

    #endRoundBtn.hidden {
      display: none;
    }

    /* Room Modal */
    #roomModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 100;
      padding: 2rem;
    }

    #roomModal.hidden {
      display: none;
    }

    .modal-content {
      background: white;
      padding: 2rem;
      border-radius: 12px;
      max-width: 400px;
      width: 100%;
      text-align: center;
    }

    .modal-content h2 {
      margin-bottom: 1.5rem;
      color: #2c3e50;
    }

    .modal-content input {
      font-family: "LXGW WenKai Mono TC", monospace;
      font-size: 1.5rem;
      text-align: center;
      padding: 0.5rem;
      border: 2px solid #ffb3ba;
      border-radius: 8px;
      width: 100%;
      margin-bottom: 1rem;
      text-transform: uppercase;
    }

    .modal-buttons {
      display: flex;
      gap: 1rem;
      justify-content: center;
    }

    .modal-buttons button {
      font-size: 1.2rem;
      padding: 0.5rem 1.5rem;
    }

    /* Submitted Words Display */
    #submittedWords {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 2rem;
      border-radius: 12px;
      max-width: 400px;
      width: 90%;
      max-height: 70%;
      overflow-y: auto;
      z-index: 5;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    }

    #submittedWords.hidden {
      display: none;
    }

    #submittedWords h3 {
      margin-bottom: 1rem;
      color: #2c3e50;
      text-align: center;
    }

    .word-list {
      list-style: none;
      padding: 0;
    }

    .word-list li {
      padding: 0.5rem;
      margin-bottom: 0.5rem;
      background: #f8f9fa;
      border-radius: 8px;
      font-size: 1.2rem;
      text-align: center;
      transition: background 0.3s ease;
    }

    .word-list li.own-word {
      background: #ffb3ba;
      font-weight: bold;
    }

    .word-list li.distance-0 {
      background: #ffb3ba;
    }

    .word-list li.distance-1 {
      background: #ffc4c4;
    }

    .word-list li.distance-2 {
      background: #ffd5d5;
    }

    .word-list li.distance-3 {
      background: #ffe6e6;
    }

    .word-list li.distance-4 {
      background: #fff0f0;
    }

    #currentWordDisplay {
      text-align: center;
      margin-bottom: 1rem;
      padding: 0.5rem;
      background: #e8f4f8;
      border-radius: 8px;
      font-size: 1.3rem;
      font-weight: bold;
      color: #2c3e50;
    }

    #currentWordDisplay.hidden {
      display: none;
    }

    #showClueBtn {
      width: 100%;
      margin-top: 1rem;
      font-size: 1.2rem;
      padding: 0.8rem;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="mainMenu">
      <div id="langPicker">
        <label><input type="radio" name="lang" value="en" checked> English</label>
        <label><input type="radio" name="lang" value="gr"> Greek</label>
      </div>
      <button id="btnWord">Get Word</button>
      <button id="btnClue">Type Clue</button>
    </div>

    <div id="wordDisplay" class="hidden">
      <div id="wordText" class="fullscreenView">
        <span id="wordInner"></span>
      </div>
    </div>

    <div id="clueInput" class="hidden">
      <form id="clueForm" autocomplete="off">
        <div class="input-container">
          <input id="clueField" type="text" maxlength="30" placeholder="Enter one-word clue" pattern="\S+" required>
          <button type="submit" id="submitBtn">‚Üí</button>
        </div>
      </form>
    </div>

    <div id="clueDisplay" class="hidden">
      <div id="clueText" class="fullscreenView">
        <span id="clueInner"></span>
      </div>
    </div>

    <button id="backBtn" class="hidden">‚Üê</button>
    <button id="fsBtn" title="Toggle Fullscreen">‚õ∂</button>

    <div id="roomBadge" class="hidden"></div>
    <button id="endRoundBtn" class="hidden">End Round</button>

    <div id="roomModal" class="hidden">
      <div class="modal-content">
        <h2>Join Room</h2>
        <input type="text" id="roomCodeInput" placeholder="ABCD" maxlength="4" pattern="[A-Za-z]{4}">
        <div class="modal-buttons">
          <button id="joinRoomBtn">Join Room</button>
          <button id="newRoomBtn">New Room</button>
        </div>
        <button id="offlineBtn" style="margin-top: 2rem; width: 100%; font-size: 1.3rem;">Play Offline</button>
      </div>
    </div>

    <div id="submittedWords" class="hidden">
      <h3>Submitted Words</h3>
      <div id="currentWordDisplay" class="hidden"></div>
      <ul class="word-list" id="wordsList"></ul>
      <button id="showClueBtn">Show Clue</button>
    </div>
  </div>

  <script>
    // Dynamic text scaling function (FitText.js-like)
    function fitText(element, minFontSize = 20, maxFontSize = 300) {
      if (!element || !element.textContent.trim()) return;

      const container = element.parentElement;
      const containerWidth = container.clientWidth * 0.9;
      const containerHeight = container.clientHeight * 0.9;

      let fontSize = minFontSize;
      element.style.fontSize = fontSize + 'px';
      element.style.whiteSpace = 'nowrap';

      // Binary search for optimal font size
      let low = minFontSize;
      let high = maxFontSize;

      while (low <= high) {
        fontSize = Math.floor((low + high) / 2);
        element.style.fontSize = fontSize + 'px';

        if (element.scrollWidth <= containerWidth && element.scrollHeight <= containerHeight) {
          low = fontSize + 1;
        } else {
          high = fontSize - 1;
        }
      }

      element.style.fontSize = high + 'px';
    }

    const englishWords=["Accent", "Acorn", "Aladdin", "Alarm", "Alcatraz", "Alcohol", "Alien", "Alliance", "Amazon", "America", "Anchor", "Angel", "Anniversary", "Antarctica", "Apple", "Armstrong", "Australia", "Avatar", "Baby", "Baker", "Bald", "Ball", "Ballet", "Banana", "Band", "Bar", "Barbecue", "Barbie", "Bath", "Batman", "Battery", "Beer", "Belgium", "Bellybutton", "Belt", "Berry", "Bet", "Binoculars", "Blond", "Board", "Bone", "Bonfire", "Book", "Boss", "Bottle", "Bow", "Bowling", "Boxing", "Bracelet", "Brain", "Branch", "Bread", "Bridge", "Brush", "Bubble", "Buffy", "Burrito", "Butterfly", "Button", "Cactus", "Caesar", "Cafeteria", "Cake", "Calendar", "Canada", "Candy", "Cane", "Cannon", "Canteen", "Canvas", "Carnival", "Carousel", "Carpet", "Carton", "Cartoon", "Casino", "Castle", "Cat", "Caterpillar", "Cave", "Cavity", "Cell", "Cemetery", "Cereal", "Chain", "Champagne", "Cheddar", "Cheese", "Chewbacca", "Chicken", "Chile", "Chip", "Chocolate", "Christmas", "Churchill", "Cigarette", "Cinderella", "Cinema", "Circus", "Cleopatra", "Climb", "Clover", "Club", "Cockroach", "Cocktail", "Cocoon", "Coffee", "Colonel", "Comedy", "Comforter", "Computer", "Concert", "Cookie", "Cork", "Corner", "Cougar", "Crane", "Crepe", "Crocodile", "Croissant", "Cross", "Crossroads", "Crown", "Cube", "Cup", "Cupid", "Cycle", "Dance", "Darwin", "Decathlon", "Defense", "Dentist", "Desert", "Devil", "Diamond", "Dinosaur", "Disco", "Doctor", "Doll", "Doping", "Dracula", "Drag", "Dream", "Dune", "Dwarf", "Easter", "Egg", "Elastic", "Election", "Electricity", "Elephant", "Elf", "Elvis", "Emergency", "Emperor", "End", "Evening", "Everest", "Explosion", "Facebook", "Failure", "Fair", "Fairy", "Fall", "Farm", "Fashion", "Fever", "Fire", "Firecracker", "Fireman", "Fitzgerald", "Flame", "Flash", "Flight", "Flintstone", "Flower", "Flute", "Foam", "Ford", "Forest", "Fork", "Fountain", "Fox", "France", "Frankenstein", "Friday", "Fries", "Frost", "Fur", "Galaxy", "Game", "Gandhi", "Garden", "Garlic", "Genius", "Ghost", "Giant", "Gladiator", "Glass", "Glasses", "Goal", "Godfather", "Godzilla", "Golf", "Google", "Gothic", "Grass", "Greece", "Gremlins", "Grenade", "Grotto", "Guard", "Guillotine", "Gumbo", "Hair", "Hairdresser", "Halloween", "Hammer", "Handle", "Hanukkah", "Hat", "Hazelnut", "Heart", "Heel", "Helicopter", "Helmet", "History", "Hockey", "Hole", "Hollywood", "Honey", "Hose", "Hotel", "House", "Hulk", "Human", "Humor", "Hunter", "Ice", "Ikea", "Iris", "Iron", "Island", "Israel", "Italy", "Jackson", "Jedi", "Jewelry", "Joker", "Jones", "Jungle", "Karate", "King", "Knife", "Knight", "Ladder", "Ladybug", "Lake", "Lamp", "Language", "Large", "Lava", "Lawyer", "Leaf", "Leap", "Lego", "Letter", "Light", "Lightbulb", "Lighthouse", "Lightning", "Limb", "Lion", "Lonely", "Lottery", "Machine", "Mad", "Mafia", "Magician", "Magnet", "Manual", "Manure", "Map", "Mario", "Market", "Marriage", "Mars", "Mask", "Matrix", "Melon", "Metal", "Mexico", "Mickey", "Microsoft", "Milk", "Mill", "Mirage", "Mirror", "Missile", "Monkey", "Monopoly", "Moon", "Moscow", "Mosquito", "Mountain", "Mouse", "Mouth", "Mower", "Mozart", "Mummy", "Muse", "Mushroom", "Music", "Musketeer", "Mustache", "Mustard", "Myth", "Nail", "Necklace", "Needle", "Neighborhood", "Nest", "New", "Newspaper", "Nile", "Ninja", "Nintendo", "Noodle", "Nuclear", "Number", "Nun", "Oasis", "Octopus", "Olympics", "Opera", "Operation", "Oprah", "Orange", "Oven", "Painting", "Pair", "Palace", "Pan", "Panda", "Parachute", "Paradise", "Parrot", "Passion", "Peace", "Peach", "Peanut", "Pear", "Pebble", "Penguin", "Pepper", "Perfume", "Picasso", "Pie", "Pig", "Pigeon", "Pikachu", "Pillow", "Pilot", "Pimento", "Pipe", "Pirate", "Pit", "Pizza", "Plane", "Plastic", "Playstation", "Plier", "Poison", "Poker", "Polar", "Pole", "Police", "Pony", "Pool", "Pope", "Porcelain", "Potato", "Potter", "Powder", "Pregnant", "President", "Primary", "Princess", "Prison", "Prom", "Psycho", "Pump", "Punk", "Puppet", "Purse", "Pyramid", "Radio", "Rail", "Rain", "Rake", "Ram", "Rambo", "Ramses", "Rap", "Rat", "Ray", "Reggae", "Register", "Revolution", "Ring", "Ripe", "River", "Robot", "Rock", "Rocky", "Room", "Rooster", "Root", "Rope", "Rose", "Ruler", "Rum", "Safari", "Safe", "Sahara", "Sail", "Salt", "Sand", "Sausage", "Scale", "Scene", "School", "Screw", "Series", "Sewer", "Shack", "Shakespeare", "Shark", "Sheep", "Shelf", "Shell", "Sherlock", "Ship", "Shovel", "Shower", "Shrek", "Shrimp", "Simpson", "Siren", "Ski", "Sleeve", "Slipper", "Smoke", "Snake", "Snow", "Soap", "Sock", "Socket", "Sofa", "Sombrero", "Song", "Spartacus", "Spear", "Spice", "Spielberg", "Spy", "Stallion", "Star", "Starbucks", "Stark", "Station", "Stew", "Sting", "Stone", "Straw", "Strawberry", "String", "Study", "Stuffing", "Subway", "Sugar", "Sun", "Switzerland", "Sword", "Syrup", "Tango", "Tarantino", "Tarzan", "Tattoo", "Taxi", "Temple", "Tennis", "Terminator", "Theater", "Thought", "Thread", "Throat", "Thunder", "Ticket", "Tie", "Tiger", "Titanic", "Tobacco", "Tokyo", "Tolkien", "Tomato", "Tool", "Tornado", "Towel", "Tower", "Tradition", "Train", "Treasure", "Triangle", "Troy", "Truce", "Tube", "Tulip", "Tuna", "Tunnel", "Umbrella", "Unicorn", "Uniform", "Vacation", "Vampire", "Vegas", "Vegetable", "Vengeance", "Venus", "Viking", "Violin", "Virus", "Volcano", "Waltz", "War", "Watch", "Wave", "Weather", "Western", "Wheat", "White", "Widowmaker", "Wind", "Window", "Wine", "Wolf", "Yellow", "Zeus", "Zombie", "Zoo"];

    const greekWords=[
      "ŒµŒªŒ≠œÜŒ±ŒΩœÑŒ±œÇ","œÖœÄŒøŒªŒøŒ≥ŒπœÉœÑŒÆœÇ","ŒµœÖœÑœÖœáŒØŒ±","Œ∏Œ¨ŒªŒ±œÉœÉŒ±","œÄŒµœÑŒ±ŒªŒøœçŒ¥Œ±","Œ≤ŒøœÖŒΩœå",
      "œÜŒπŒªŒØŒ±","ŒøœÖœÅŒ¨ŒΩŒπŒø œÑœåŒæŒø","Œ∫ŒπŒ∏Œ¨œÅŒ±","œÄŒØœÑœÉŒ±","Œ∑œÜŒ±ŒØœÉœÑŒµŒπŒø","Œ¥ŒπŒ±ŒºŒ¨ŒΩœÑŒπ","Œ¥Œ¨œÉŒøœÇ",
      "Œ∫Œ¨œÉœÑœÅŒø","Œ¥ŒπŒ±œÉœÑŒ∑ŒºœåœÄŒªŒøŒπŒø","œÄœÖœÅŒ±ŒºŒØŒ¥Œ±","ŒΩŒ∑œÉŒØ","œàŒØŒ∏œÖœÅŒøœÇ","Œ∫Œ±œÑŒ±ŒπŒ≥ŒØŒ¥Œ±",
      "œÄœçœÅŒ±œÖŒªŒøœÇ","Œ∏Œ∑œÉŒ±œÖœÅœåœÇ","œÄŒøœÑŒ¨ŒºŒπ","Œ≥Œ±ŒªŒ±ŒæŒØŒ±œÇ","œÉŒøŒ∫ŒøŒªŒ¨œÑŒ±","Œ≠œÅŒ∑ŒºŒøœÇ",
      "œÉœÖŒºœÜœâŒΩŒØŒ±","Œ≥œÅŒØœÜŒøœÇ","Œ∫Œ±Œ∏œÅŒ≠œÜœÑŒ∑œÇ","Œ∂ŒøœçŒ≥Œ∫ŒªŒ±","Œ∫Œ¨ŒºŒµœÅŒ±","Œ¥œÅŒ¨Œ∫ŒøœÇ","Œ≤ŒπŒ≤ŒªŒπŒøŒ∏ŒÆŒ∫Œ∑",
      "œÑœÉŒØœÅŒ∫Œø","œÄŒ±œÅŒ¨Œ¥ŒµŒπœÉŒøœÇ","œÄœÖœÅŒøœÑŒµœáŒΩŒÆŒºŒ±œÑŒ±","œÉŒ±œÜŒ¨œÅŒπ","ŒºŒøŒΩœåŒ∫ŒµœÅŒøœÇ","ŒªŒ±Œ≤œçœÅŒπŒΩŒ∏ŒøœÇ",
      "œÜŒµœÉœÑŒπŒ≤Œ¨Œª","Œ±ŒΩŒµŒºŒøœÉœÑœÅœåŒ≤ŒπŒªŒøœÇ","œÜŒ±ŒΩŒ¨œÅŒπ","ŒºœÖœÉœÑŒÆœÅŒπŒø","Œ∫Œ±œÅŒøœÖŒ∂Œ≠Œª","Œ∫Œ±œÅœçŒ¥Œ±",
      "œÄŒ±Œ≥œåŒ≤ŒøœÖŒΩŒø","œÄœÖŒæŒØŒ¥Œ±","ŒøœÅœáŒπŒ¥Œ≠Œ±","Œ±ŒΩŒ±œÑŒøŒªŒÆ","œÑŒ∑ŒªŒµœÉŒ∫œåœÄŒπŒø","œÉŒøŒ¥ŒµŒπŒ¨"
    ];

    const mainMenu = document.getElementById('mainMenu');
    const wordDisplay = document.getElementById('wordDisplay');
    const clueInput = document.getElementById('clueInput');
    const clueDisplay = document.getElementById('clueDisplay');
    const backBtn = document.getElementById('backBtn');
    const fsBtn = document.getElementById('fsBtn');
    const wordInner = document.getElementById('wordInner');
    const clueInner = document.getElementById('clueInner');
    const clueField = document.getElementById('clueField');

    let currentWord = '';
    let currentView = 'menu';
    let currentLang = 'en';
    let countdownId = null;
    let wordBlurred = false;
    let wordRevealed = false;

    // Multiplayer state
    let clientUUID = '';
    let roomCode = '';
    let gweetController = null;
    let submittedWords = [];
    let hasSubmittedWord = false;
    let lastNewGameTime = null;
    let lastEndRoundTime = null;
    let wordHolderUUID = null; // Track who has the word
    let currentUserRole = null; // 'wordHolder' or 'clueGiver' or null
    let isOfflineMode = false; // Track offline mode

    // Language picker
    document.querySelectorAll('[name="lang"]').forEach(radio => {
      radio.addEventListener('change', e => {
        currentLang = e.target.value;
      });
    });

    // Calculate Levenshtein distance between two strings (case-insensitive)
    function levenshteinDistance(string_a, string_b) {
      const a = string_a.toLowerCase();
      const b = string_b.toLowerCase();

      if (a.length === 0) return b.length;
      if (b.length === 0) return a.length;

      const matrix = [];

      // Initialize the first column
      for (let i = 0; i <= b.length; i++) {
        matrix[i] = [i];
      }

      // Initialize the first row
      for (let j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
      }

      // Calculate distances
      for (let i = 1; i <= b.length; i++) {
        for (let j = 1; j <= a.length; j++) {
          if (b.charAt(i - 1) === a.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(
              matrix[i - 1][j - 1] + 1, // substitution
              matrix[i][j - 1] + 1,     // insertion
              matrix[i - 1][j] + 1      // deletion
            );
          }
        }
      }

      return matrix[b.length][a.length];
    }

    // Generate UUID for client identification
    function generateUUID() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    }

    // Generate room code
    function generateRoomCode() {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      let code = '';
      for (let i = 0; i < 4; i++) {
        code += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return code;
    }

    // Initialize client UUID on load
    clientUUID = generateUUID();

    // Room management
    const roomBadge = document.getElementById('roomBadge');
    const roomModal = document.getElementById('roomModal');
    const roomCodeInput = document.getElementById('roomCodeInput');
    const submittedWordsDiv = document.getElementById('submittedWords');
    const wordsList = document.getElementById('wordsList');
    const currentWordDisplay = document.getElementById('currentWordDisplay');
    const endRoundBtn = document.getElementById('endRoundBtn');

    // Initialize button visibility on load
    updateButtonVisibility();

    // Show room modal on load
    setTimeout(() => {
      roomModal.classList.remove('hidden');
      roomCodeInput.focus();
    }, 100);

    // Room badge click handler
    roomBadge.addEventListener('click', () => {
      if (roomCode) {
        navigator.clipboard.writeText(roomCode).then(() => {
          const originalText = roomBadge.textContent;
          roomBadge.textContent = 'Copied!';
          setTimeout(() => {
            roomBadge.textContent = originalText;
          }, 1500);
        });
      }
    });

    // Join room button
    document.getElementById('joinRoomBtn').addEventListener('click', () => {
      const code = roomCodeInput.value.toUpperCase();
      if (code && /^[A-Z]{4}$/.test(code)) {
        connectToRoom(code);
      } else {
        alert('Please enter a valid 4-letter room code');
      }
    });

    // Handle Enter key in room code input
    roomCodeInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        document.getElementById('joinRoomBtn').click();
      }
    });

    // New room button
    document.getElementById('newRoomBtn').addEventListener('click', () => {
      const code = generateRoomCode();
      roomCodeInput.value = code;
      connectToRoom(code);
    });

    // Offline mode button
    document.getElementById('offlineBtn').addEventListener('click', () => {
      isOfflineMode = true;
      roomModal.classList.add('hidden');
      // Don't show the room badge in offline mode
      roomBadge.classList.add('hidden');
      // Update button visibility for offline mode
      updateButtonVisibility();
    });

    // Connect to room
    function connectToRoom(code) {
      roomCode = code;
      roomBadge.textContent = `Room: ${code}`;
      roomBadge.classList.remove('hidden');
      roomModal.classList.add('hidden');

      // Connect to Gweet
      connectToGweet();

      // Update button visibility after connecting
      updateButtonVisibility();
    }

    // Gweet connection management
    async function connectToGweet() {
      // Skip in offline mode
      if (isOfflineMode) return;

      // Disconnect existing connection
      if (gweetController) {
        gweetController.abort();
      }

      const channelKey = `justone-stavros-${roomCode.toLowerCase()}`;
      gweetController = new AbortController();

      try {
        // Fetch historical messages
        const historyResponse = await fetch(`https://gweet.stavros.io/stream/${channelKey}/?latest=10`);
        const historyData = await historyResponse.json();

        // Process historical messages (filter by age)
        const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
        if (historyData.messages) {
          // Filter messages by age first
          const recentMessages = historyData.messages.filter(msg =>
            new Date(msg.created) >= oneHourAgo
          );

          // Find the last endRound message
          let lastEndRoundIndex = -1;
          for (let i = recentMessages.length - 1; i >= 0; i--) {
            const msg = recentMessages[i];
            const type = msg.values?.type?.[0];
            if (type === 'endRound') {
              lastEndRoundIndex = i;
              break;
            }
          }

          // Only process messages after the last endRound
          // If there's no endRound, process all messages
          // If the last message IS endRound, process nothing (start clean)
          const messagesToProcess = lastEndRoundIndex === -1
            ? recentMessages
            : recentMessages.slice(lastEndRoundIndex + 1);

          messagesToProcess.forEach(msg => {
            handleGweetMessage(msg.values);
          });

          // Update button visibility after processing all historical messages
          updateButtonVisibility();
        }

        // Establish streaming connection
        const streamResponse = await fetch(
          `https://gweet.stavros.io/stream/${channelKey}/?streaming=1`,
          { signal: gweetController.signal }
        );

        const reader = streamResponse.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop(); // Keep incomplete line in buffer

          for (const line of lines) {
            if (line.trim()) {
              try {
                const data = JSON.parse(line);
                if (data.values) {
                  handleGweetMessage(data.values);
                }
              } catch (e) {
                console.error('Error parsing message:', e);
              }
            }
          }
        }
      } catch (error) {
        if (error.name !== 'AbortError') {
          console.error('Gweet connection error:', error);
          // Retry after 5 seconds
          setTimeout(() => {
            if (roomCode) {
              connectToGweet();
            }
          }, 5000);
        }
      }
    }

    // Handle incoming Gweet messages
    function handleGweetMessage(data) {
      let type, word, lang, user;

      // Parse message based on format
      if (typeof data === 'object' && data !== null) {
        type = data.type?.[0];
        word = data.word?.[0];
        lang = data.lang?.[0];
        user = data.user?.[0];
      } else if (typeof data === 'string') {
        try {
          const jsonData = JSON.parse(data);
          if (jsonData.values) {
            return handleGweetMessage(jsonData.values);
          }
        } catch {
          // Parse as URL-encoded
          const params = new URLSearchParams(data);
          type = params.get('type');
          word = params.get('word');
          lang = params.get('lang');
          user = params.get('user');
        }
      }

      // Process based on message type
      if (type === 'newGame') {
        // Track timing of new game
        lastNewGameTime = Date.now();

        // Track who has the word
        wordHolderUUID = user;

        // Set current user's role
        if (user === clientUUID) {
          currentUserRole = 'wordHolder';
        } else {
          currentUserRole = 'clueGiver';
          currentWord = word;
          currentLang = lang || 'en';
          // Update language selector
          document.querySelector(`[name="lang"][value="${currentLang}"]`).checked = true;
        }

        // Reset submitted words
        submittedWords = [];
        hasSubmittedWord = false;
        updateSubmittedWordsDisplay();

        // Update button visibility
        updateButtonVisibility();
      } else if (type === 'submitWord' && word) {
        // Word submitted by a player
        const submission = { word, user };
        // Check if this word hasn't been added already
        if (!submittedWords.some(s => s.word === word && s.user === user)) {
          submittedWords.push(submission);
          updateSubmittedWordsDisplay();
        }
      } else if (type === 'endRound') {
        // Track timing of end round
        lastEndRoundTime = Date.now();

        // Round ended by another player
        handleEndRound();
      }
    }

    // Send message to Gweet
    async function sendGweetMessage(message) {
      if (!roomCode || isOfflineMode) return;

      const channelKey = `justone-stavros-${roomCode.toLowerCase()}`;
      const params = new URLSearchParams();

      // Add user UUID to all messages
      params.append('user', clientUUID);

      // Add message fields
      for (const [key, value] of Object.entries(message)) {
        params.append(key, value);
      }

      try {
        await fetch(`https://gweet.stavros.io/stream/${channelKey}/`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          body: params.toString()
        });
      } catch (error) {
        console.error('Error sending message:', error);
      }
    }

    // Update submitted words display
    function updateSubmittedWordsDisplay() {
      if (!hasSubmittedWord) {
        submittedWordsDiv.classList.add('hidden');
        return;
      }

      // Show the submitted words div
      submittedWordsDiv.classList.remove('hidden');

      // Show the word display
      currentWordDisplay.classList.remove('hidden');
      currentWordDisplay.textContent = currentWord ? `Word: ${currentWord}` : '';

      // Clear and rebuild the list
      wordsList.innerHTML = '';

      // Get own submission for distance calculations
      const ownSubmission = submittedWords.find(s => s.user === clientUUID);

      // Show own word first
      if (ownSubmission) {
        const li = document.createElement('li');
        li.textContent = ownSubmission.word;
        li.className = 'own-word';
        wordsList.appendChild(li);
      }

      // Show other words with distance-based coloring
      submittedWords
        .filter(s => s.user !== clientUUID)
        .forEach(submission => {
          const li = document.createElement('li');
          li.textContent = submission.word;

          // Calculate distance and apply appropriate class
          if (ownSubmission) {
            const distance = levenshteinDistance(ownSubmission.word, submission.word);
            if (distance <= 4) {
              li.className = `distance-${distance}`;
            }
            // Distance > 4 gets default grey background from base .word-list li style
          }

          wordsList.appendChild(li);
        });
    }

    // Show Clue button handler
    document.getElementById('showClueBtn').addEventListener('click', () => {
      // Hide the modal
      submittedWordsDiv.classList.add('hidden');

      // Show the clue in fullscreen
      show('clue');
      enterFullscreen();
      fitText(clueInner);
      setTimeout(() => fitText(clueInner), 100);
    });

    // Handle ending the round (clears state and returns to menu)
    function handleEndRound() {
      // Clear word state
      currentWord = '';
      submittedWords = [];
      hasSubmittedWord = false;
      wordRevealed = false;
      wordBlurred = false;

      // Clear user roles
      wordHolderUUID = null;
      currentUserRole = null;

      // Clear timing state - important for proper game state detection
      lastNewGameTime = null;
      lastEndRoundTime = null;

      // Clear any countdown
      if (countdownId) {
        clearInterval(countdownId);
        countdownId = null;
      }

      // Reset visual states
      wordInner.classList.remove('blurred');
      document.getElementById('wordText').classList.remove('word-blurred');
      submittedWordsDiv.classList.add('hidden');

      // Return to main menu BEFORE updating button visibility
      show('menu');

      // Update button visibility with correct view context
      updateButtonVisibility();
    }

    // End Round button handler
    endRoundBtn.addEventListener('click', () => {
      // Show confirmation dialog
      if (!confirm('Are you sure you want to end the round for everyone?')) {
        return;
      }

      // Track the end round timing
      lastEndRoundTime = Date.now();

      // Send endRound message to other players
      sendGweetMessage({
        type: 'endRound'
      });

      // Handle the end round locally
      handleEndRound();
    });

    // View management
    function show(view) {
      [mainMenu, wordDisplay, clueInput, clueDisplay].forEach(v => v.classList.add('hidden'));

      if (view === 'menu') {
        backBtn.classList.add('hidden');
      } else {
        backBtn.classList.remove('hidden');
      }

      switch(view) {
        case 'menu': mainMenu.classList.remove('hidden'); break;
        case 'word': wordDisplay.classList.remove('hidden'); break;
        case 'clueIn': clueInput.classList.remove('hidden'); break;
        case 'clue': clueDisplay.classList.remove('hidden'); break;
      }
      currentView = view;

      // Update all button visibility based on current state
      updateButtonVisibility();

      // Update browser history for back button handling
      if (view !== 'menu') {
        history.pushState({ view: view }, '', '#' + view);
      } else {
        history.replaceState({ view: 'menu' }, '', window.location.pathname);
      }
    }

    // Auto fullscreen helper
    function enterFullscreen() {
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
      if (!isIOS && document.documentElement.requestFullscreen && !document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(() => {});
      }
    }

    // Check if a game is currently in progress
    function isGameInProgress() {
      // No game has been started yet
      if (!lastNewGameTime) {
        return false;
      }

      // If there's been an endRound after the last newGame, no game is in progress
      if (lastEndRoundTime && lastEndRoundTime > lastNewGameTime) {
        return false;
      }

      // If there's been a newGame but no endRound after it, game is in progress
      return true;
    }

    // Update button visibility based on user role and game state
    function updateButtonVisibility() {
      const btnWord = document.getElementById('btnWord');
      const btnClue = document.getElementById('btnClue');

      if (isOfflineMode) {
        // Offline mode - both buttons always enabled
        btnWord.classList.remove('disabled');
        btnClue.classList.remove('disabled');
        // Hide End Round button in offline mode
        endRoundBtn.classList.add('hidden');
      } else if (!isGameInProgress()) {
        // No game in progress - anyone can start a new game
        btnWord.classList.remove('disabled');
        btnClue.classList.add('disabled');
        endRoundBtn.classList.add('hidden');
      } else {
        // Game in progress - show End Round button
        if (currentView === 'menu' || currentView === 'word' || currentView === 'clue') {
          endRoundBtn.classList.remove('hidden');
        }

        // Check user role for main buttons
        if (currentUserRole === 'wordHolder') {
          // Word holder can click "Get Word" to see their word
          btnWord.classList.remove('disabled');
          btnClue.classList.add('disabled');
        } else if (currentUserRole === 'clueGiver') {
          // Clue giver can click "Type Clue" or see submitted words
          btnWord.classList.add('disabled');
          btnClue.classList.remove('disabled');
        } else {
          // Edge case: game in progress but no role assigned yet
          // This can happen briefly during message processing
          btnWord.classList.add('disabled');
          btnClue.classList.add('disabled');
        }
      }
    }

    // Get Word button
    document.getElementById('btnWord').onclick = () => {
      // In offline mode, always allow getting a new word
      if (isOfflineMode) {
        const pool = currentLang === 'en' ? englishWords : greekWords;
        currentWord = pool[Math.floor(Math.random() * pool.length)];

        show('word');
        enterFullscreen();

        let seconds = 2;
        wordInner.textContent = seconds;
        fitText(wordInner);
        wordRevealed = false;
        wordBlurred = false;

        if (countdownId) clearInterval(countdownId);
        countdownId = setInterval(() => {
          seconds--;
          if (seconds <= 0) {
            clearInterval(countdownId);
            countdownId = null;
            wordInner.textContent = currentWord;
            wordRevealed = true;
          } else {
            wordInner.textContent = seconds;
          }
          fitText(wordInner);
        }, 1000);
        return;
      }

      // Check if user is the word holder returning to their word
      if (isGameInProgress() && currentUserRole === 'wordHolder') {
        // Return to the existing word
        show('word');
        enterFullscreen();
        wordInner.textContent = currentWord;
        wordRevealed = true;
        fitText(wordInner);
        return;
      }

      // Check if a game is already in progress (and user is not word holder)
      if (isGameInProgress()) {
        // Button should be disabled for clue givers
        return;
      }

      // Start a new game
      const pool = currentLang === 'en' ? englishWords : greekWords;
      currentWord = pool[Math.floor(Math.random() * pool.length)];

      // Track this new game
      lastNewGameTime = Date.now();
      wordHolderUUID = clientUUID;
      currentUserRole = 'wordHolder';

      // Reset submitted words for new game
      submittedWords = [];
      hasSubmittedWord = false;
      updateSubmittedWordsDisplay();

      // Send new game message to other players
      sendGweetMessage({
        type: 'newGame',
        word: currentWord,
        lang: currentLang
      });

      show('word');
      enterFullscreen(); // Auto enter fullscreen

      let seconds = 2;
      wordInner.textContent = seconds;
      fitText(wordInner);
      wordRevealed = false;
      wordBlurred = false;

      if (countdownId) clearInterval(countdownId);
      countdownId = setInterval(() => {
        seconds--;
        if (seconds <= 0) {
          clearInterval(countdownId);
          countdownId = null;
          wordInner.textContent = currentWord;
          wordRevealed = true;
        } else {
          wordInner.textContent = seconds;
        }
        fitText(wordInner);
      }, 1000);
    };

    // Word screen tap-to-blur functionality
    const wordText = document.getElementById('wordText');
    wordText.addEventListener('click', () => {
      if (currentView === 'word' && wordRevealed) {
        wordBlurred = !wordBlurred;
        if (wordBlurred) {
          wordInner.classList.add('blurred');
          wordText.classList.add('word-blurred');
        } else {
          wordInner.classList.remove('blurred');
          wordText.classList.remove('word-blurred');
        }

        // Haptic feedback
        if (navigator.vibrate) {
          navigator.vibrate(50); // Vibrate for 50ms
        }
      }
    });

    // Type Clue button
    document.getElementById('btnClue').onclick = () => {
      // In offline mode, always allow typing a clue
      if (isOfflineMode) {
        clueField.value = '';
        show('clueIn');
        // Focus the input field after the view is shown
        requestAnimationFrame(() => {
          clueField.focus();
          // For mobile devices, also scroll into view
          clueField.scrollIntoView({ behavior: 'smooth', block: 'center' });
        });
        return;
      }

      // Check if not in a game or not a clue giver
      if (!isGameInProgress() || currentUserRole !== 'clueGiver') {
        return;
      }

      // If user has already submitted a word, show the submitted words modal
      if (hasSubmittedWord) {
        show('clueIn');
        updateSubmittedWordsDisplay();
      } else {
        // Show clue input for new submission
        clueField.value = '';
        show('clueIn');
        // Focus the input field after the view is shown
        requestAnimationFrame(() => {
          clueField.focus();
          // For mobile devices, also scroll into view
          clueField.scrollIntoView({ behavior: 'smooth', block: 'center' });
        });
      }
    };

    // Allow only letters in clue field (any language)
    clueField.addEventListener('keydown', (e) => {
      // Allow: backspace, delete, tab, escape, enter, arrow keys
      if ([8, 9, 27, 13, 37, 38, 39, 40, 46].includes(e.keyCode) ||
          // Allow Ctrl+A, Ctrl+C, Ctrl+V, Ctrl+X, Ctrl+Z, Cmd+A, Cmd+C, Cmd+V, Cmd+X, Cmd+Z
          (e.ctrlKey === true && [65, 67, 86, 88, 90].includes(e.keyCode)) ||
          (e.metaKey === true && [65, 67, 86, 88, 90].includes(e.keyCode))) {
        return;
      }

      // For non-ASCII characters, let the input event handle the filtering
      if (e.keyCode > 127) {
        return;
      }

      // Prevent if not a letter (for ASCII characters)
      const char = String.fromCharCode(e.keyCode);
      if (!/^[a-zA-Z]$/.test(char)) {
        e.preventDefault();
      }
    });

    clueField.addEventListener('input', (e) => {
      // Remove any non-letter characters (supports all Unicode letters)
      e.target.value = e.target.value.replace(/[^\p{L}]/gu, '');
    });

    // Clue form submission
    document.getElementById('clueForm').addEventListener('submit', e => {
      e.preventDefault();
      const val = clueField.value.trim();
      if (!val) return;
      if (/\s/.test(val)) { alert('One word only!'); return; }

      // In offline mode, go straight to showing the clue
      if (isOfflineMode) {
        clueInner.textContent = val;
        show('clue');
        enterFullscreen();
        fitText(clueInner);
        setTimeout(() => fitText(clueInner), 100);
        return;
      }

      // Check if there's a word in the channel
      if (!currentWord) {
        alert('No word to give a clue for! Someone needs to start a new game first.');
        return;
      }

      // Send the submitted word to other players
      sendGweetMessage({
        type: 'submitWord',
        word: val
      });

      // Add to local submitted words
      submittedWords.push({ word: val, user: clientUUID });
      hasSubmittedWord = true;

      // Store the clue but don't show it yet
      clueInner.textContent = val;

      // Show the submitted words modal instead of going directly to clue display
      updateSubmittedWordsDisplay();

      // Stay in clueIn view with the modal on top
      // The modal will be shown by updateSubmittedWordsDisplay
    });

    // Handle browser back button/gesture
    function goBackToMenu() {
      // No confirmation needed since we're preserving state

      if (countdownId) {
        clearInterval(countdownId);
        countdownId = null;
      }

      // Reset blur state but keep the word (don't clear it)
      if (currentView === 'word') {
        wordBlurred = false;
        wordInner.classList.remove('blurred');
        document.getElementById('wordText').classList.remove('word-blurred');
      }

      // Hide submitted words modal when returning to menu
      submittedWordsDiv.classList.add('hidden');

      show('menu');
    }

    // Back button
    backBtn.onclick = () => {
      goBackToMenu();
    };

    // Handle browser back button/swipe navigation
    window.addEventListener('popstate', (event) => {
      // Show confirmation for word screen, always go back for other screens
      goBackToMenu();
    });

    // Event listeners for dynamic resizing
    window.addEventListener('resize', () => {
      if (currentView === 'word') fitText(wordInner);
      if (currentView === 'clue') fitText(clueInner);
    });

    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        if (currentView === 'word') fitText(wordInner);
        if (currentView === 'clue') fitText(clueInner);
      }, 100);
    });

    // Fullscreen functionality
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);

    if (!document.documentElement.requestFullscreen || isIOS) {
      fsBtn.style.display = 'none';
    } else {
      function updateFSIcon() {
        fsBtn.textContent = document.fullscreenElement ? 'üóó' : '‚õ∂';
      }
      fsBtn.addEventListener('click', () => {
        if (document.fullscreenElement) {
          document.exitFullscreen?.();
        } else {
          document.documentElement.requestFullscreen().catch(() => {});
        }
      });
      document.addEventListener('fullscreenchange', updateFSIcon);
      updateFSIcon();
    }
  </script>
</body>
</html>
