<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#ffb3ba">
  <link rel="manifest" href="./manifest.json">
  <link rel="icon" type="image/png" sizes="192x192" href="./icon-192.png">
  <link rel="apple-touch-icon" href="./icon-192.png">
  <link media="all" rel="stylesheet" href="./style.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=LXGW+WenKai+Mono+TC&display=swap" rel="stylesheet">
  <title>Just One</title>
  <script src="./game.js"></script>
</head>

<body>
  <div id="app">
    <div id="mainMenu">
      <div id="scoreDisplay">
        Score: <span id="scoreValue">0</span> | Games: <span id="gamesValue">0</span>
      </div>
      <div id="langPicker">
        <label><input type="radio" name="lang" value="en" checked> English</label>
        <label><input type="radio" name="lang" value="gr"> Greek</label>
      </div>
      <div id="playerList" class="player-list-container">
        <div id="playerCount" class="player-count"></div>
        <ul id="playerListItems" class="player-list"></ul>
      </div>
      <button id="btnWord">Get Word</button>
      <button id="btnClue">Type Clue</button>
    </div>

    <div id="wordDisplay" class="hidden">
      <div id="wordText" class="fullscreenView">
        <span id="wordInner"></span>
      </div>
    </div>

    <div id="clueInput" class="hidden">
      <form id="clueForm" autocomplete="off">
        <div class="input-container">
          <input id="clueField" type="text" maxlength="30" placeholder="Enter one-word clue" pattern="[^\s]+" required>
          <button type="submit" id="submitBtn">→</button>
        </div>
      </form>
    </div>

    <div id="clueDisplay" class="hidden">
      <div id="clueText" class="fullscreenView">
        <span id="clueInner"></span>
      </div>
    </div>

    <button id="backBtn" class="hidden">←</button>
    <button id="fsBtn" title="Toggle Fullscreen">⛶</button>

    <div id="roomBadge" class="hidden"></div>
    <button id="endRoundBtn" class="hidden">End Round</button>

    <div id="roomModal" class="hidden">
      <div class="modal-content">
        <h2>Join Room</h2>
        <input type="text" id="nameInput" placeholder="Your name" maxlength="20" style="margin-bottom: 1rem;">
        <input type="text" id="roomCodeInput" placeholder="Room code (ABCD)" maxlength="4" pattern="[A-Za-z]{4}">
        <div class="modal-buttons">
          <button id="newRoomBtn">New Room</button>
          <button id="joinRoomBtn">Join Room</button>
        </div>
        <button id="offlineBtn" style="margin-top: 2rem; width: 100%; font-size: 1.3rem;">Play Offline</button>
      </div>
    </div>

    <div id="submittedWords" class="hidden">
      <h3>Submitted Words</h3>
      <div id="currentWordDisplay" class="hidden"></div>
      <ul class="word-list" id="wordsList"></ul>
      <button id="showClueBtn">Show Clue</button>
    </div>

    <div id="connectionError" class="connection-error hidden">
      <div class="error-header">
        <div class="error-title">⚠️ Connection Error</div>
        <button class="error-close" onclick="hideConnectionError()">✕</button>
      </div>
      <div id="errorMessage" class="error-message"></div>
    </div>

    <div id="scoreNotification" class="score-notification hidden">
      <div id="scoreNotificationText"></div>
    </div>

    <div id="scoringModal" class="modal hidden">
      <div class="modal-content">
        <h2>How did the round go?</h2>
        <div id="scoringWord" class="scoring-word"></div>
        <div class="scoring-buttons">
          <button id="correctBtn" class="scoring-btn correct">✓ Correct<br><span class="score-value">(+1)</span></button>
          <button id="passBtn" class="scoring-btn neutral">→ Pass<br><span class="score-value">(0)</span></button>
          <button id="failBtn" class="scoring-btn fail">✗ Fail<br><span class="score-value">(-1)</span></button>
        </div>
        <button id="skipRoundBtn" class="skip-btn">Skip Round<br><span class="score-value">(not counted)</span></button>
        <button id="cancelScoringBtn" class="cancel-btn">Cancel</button>
      </div>
    </div>
  </div>

  <script>
    // Dynamic text scaling function (FitText.js-like)
    function fitText(element, minFontSize = 20, maxFontSize = 300) {
      if (!element || !element.textContent.trim()) return;

      const container = element.parentElement;
      const containerWidth = container.clientWidth * 0.9;
      const containerHeight = container.clientHeight * 0.9;

      let fontSize = minFontSize;
      element.style.fontSize = fontSize + 'px';
      element.style.whiteSpace = 'nowrap';

      // Binary search for optimal font size
      let low = minFontSize;
      let high = maxFontSize;

      while (low <= high) {
        fontSize = Math.floor((low + high) / 2);
        element.style.fontSize = fontSize + 'px';

        if (element.scrollWidth <= containerWidth && element.scrollHeight <= containerHeight) {
          low = fontSize + 1;
        } else {
          high = fontSize - 1;
        }
      }

      element.style.fontSize = high + 'px';
    }

    const englishWords=["Accent", "Acorn", "Aladdin", "Alarm", "Alcatraz", "Alcohol", "Alien", "Alliance", "Amazon", "America", "Anchor", "Angel", "Anniversary", "Antarctica", "Apple", "Armstrong", "Australia", "Avatar", "Baby", "Baker", "Bald", "Ball", "Ballet", "Banana", "Band", "Bar", "Barbecue", "Barbie", "Bath", "Batman", "Battery", "Beer", "Belgium", "Bellybutton", "Belt", "Berry", "Bet", "Binoculars", "Blond", "Board", "Bone", "Bonfire", "Book", "Boss", "Bottle", "Bow", "Bowling", "Boxing", "Bracelet", "Brain", "Branch", "Bread", "Bridge", "Brush", "Bubble", "Buffy", "Burrito", "Butterfly", "Button", "Cactus", "Caesar", "Cafeteria", "Cake", "Calendar", "Canada", "Candy", "Cane", "Cannon", "Canteen", "Canvas", "Carnival", "Carousel", "Carpet", "Carton", "Cartoon", "Casino", "Castle", "Cat", "Caterpillar", "Cave", "Cavity", "Cell", "Cemetery", "Cereal", "Chain", "Champagne", "Cheddar", "Cheese", "Chewbacca", "Chicken", "Chile", "Chip", "Chocolate", "Christmas", "Churchill", "Cigarette", "Cinderella", "Cinema", "Circus", "Cleopatra", "Climb", "Clover", "Club", "Cockroach", "Cocktail", "Cocoon", "Coffee", "Colonel", "Comedy", "Comforter", "Computer", "Concert", "Cookie", "Cork", "Corner", "Cougar", "Crane", "Crepe", "Crocodile", "Croissant", "Cross", "Crossroads", "Crown", "Cube", "Cup", "Cupid", "Cycle", "Dance", "Darwin", "Decathlon", "Defense", "Dentist", "Desert", "Devil", "Diamond", "Dinosaur", "Disco", "Doctor", "Doll", "Doping", "Dracula", "Drag", "Dream", "Dune", "Dwarf", "Easter", "Egg", "Elastic", "Election", "Electricity", "Elephant", "Elf", "Elvis", "Emergency", "Emperor", "End", "Evening", "Everest", "Explosion", "Facebook", "Failure", "Fair", "Fairy", "Fall", "Farm", "Fashion", "Fever", "Fire", "Firecracker", "Fireman", "Fitzgerald", "Flame", "Flash", "Flight", "Flintstone", "Flower", "Flute", "Foam", "Ford", "Forest", "Fork", "Fountain", "Fox", "France", "Frankenstein", "Friday", "Fries", "Frost", "Fur", "Galaxy", "Game", "Gandhi", "Garden", "Garlic", "Genius", "Ghost", "Giant", "Gladiator", "Glass", "Glasses", "Goal", "Godfather", "Godzilla", "Golf", "Google", "Gothic", "Grass", "Greece", "Gremlins", "Grenade", "Grotto", "Guard", "Guillotine", "Gumbo", "Hair", "Hairdresser", "Halloween", "Hammer", "Handle", "Hanukkah", "Hat", "Hazelnut", "Heart", "Heel", "Helicopter", "Helmet", "History", "Hockey", "Hole", "Hollywood", "Honey", "Hose", "Hotel", "House", "Hulk", "Human", "Humor", "Hunter", "Ice", "Ikea", "Iris", "Iron", "Island", "Israel", "Italy", "Jackson", "Jedi", "Jewelry", "Joker", "Jones", "Jungle", "Karate", "King", "Knife", "Knight", "Ladder", "Ladybug", "Lake", "Lamp", "Language", "Large", "Lava", "Lawyer", "Leaf", "Leap", "Lego", "Letter", "Light", "Lightbulb", "Lighthouse", "Lightning", "Limb", "Lion", "Lonely", "Lottery", "Machine", "Mad", "Mafia", "Magician", "Magnet", "Manual", "Manure", "Map", "Mario", "Market", "Marriage", "Mars", "Mask", "Matrix", "Melon", "Metal", "Mexico", "Mickey", "Microsoft", "Milk", "Mill", "Mirage", "Mirror", "Missile", "Monkey", "Monopoly", "Moon", "Moscow", "Mosquito", "Mountain", "Mouse", "Mouth", "Mower", "Mozart", "Mummy", "Muse", "Mushroom", "Music", "Musketeer", "Mustache", "Mustard", "Myth", "Nail", "Necklace", "Needle", "Neighborhood", "Nest", "New", "Newspaper", "Nile", "Ninja", "Nintendo", "Noodle", "Nuclear", "Number", "Nun", "Oasis", "Octopus", "Olympics", "Opera", "Operation", "Oprah", "Orange", "Oven", "Painting", "Pair", "Palace", "Pan", "Panda", "Parachute", "Paradise", "Parrot", "Passion", "Peace", "Peach", "Peanut", "Pear", "Pebble", "Penguin", "Pepper", "Perfume", "Picasso", "Pie", "Pig", "Pigeon", "Pikachu", "Pillow", "Pilot", "Pimento", "Pipe", "Pirate", "Pit", "Pizza", "Plane", "Plastic", "Playstation", "Plier", "Poison", "Poker", "Polar", "Pole", "Police", "Pony", "Pool", "Pope", "Porcelain", "Potato", "Potter", "Powder", "Pregnant", "President", "Primary", "Princess", "Prison", "Prom", "Psycho", "Pump", "Punk", "Puppet", "Purse", "Pyramid", "Radio", "Rail", "Rain", "Rake", "Ram", "Rambo", "Ramses", "Rap", "Rat", "Ray", "Reggae", "Register", "Revolution", "Ring", "Ripe", "River", "Robot", "Rock", "Rocky", "Room", "Rooster", "Root", "Rope", "Rose", "Ruler", "Rum", "Safari", "Safe", "Sahara", "Sail", "Salt", "Sand", "Sausage", "Scale", "Scene", "School", "Screw", "Series", "Sewer", "Shack", "Shakespeare", "Shark", "Sheep", "Shelf", "Shell", "Sherlock", "Ship", "Shovel", "Shower", "Shrek", "Shrimp", "Simpson", "Siren", "Ski", "Sleeve", "Slipper", "Smoke", "Snake", "Snow", "Soap", "Sock", "Socket", "Sofa", "Sombrero", "Song", "Spartacus", "Spear", "Spice", "Spielberg", "Spy", "Stallion", "Star", "Starbucks", "Stark", "Station", "Stew", "Sting", "Stone", "Straw", "Strawberry", "String", "Study", "Stuffing", "Subway", "Sugar", "Sun", "Switzerland", "Sword", "Syrup", "Tango", "Tarantino", "Tarzan", "Tattoo", "Taxi", "Temple", "Tennis", "Terminator", "Theater", "Thought", "Thread", "Throat", "Thunder", "Ticket", "Tie", "Tiger", "Titanic", "Tobacco", "Tokyo", "Tolkien", "Tomato", "Tool", "Tornado", "Towel", "Tower", "Tradition", "Train", "Treasure", "Triangle", "Troy", "Truce", "Tube", "Tulip", "Tuna", "Tunnel", "Umbrella", "Unicorn", "Uniform", "Vacation", "Vampire", "Vegas", "Vegetable", "Vengeance", "Venus", "Viking", "Violin", "Virus", "Volcano", "Waltz", "War", "Watch", "Wave", "Weather", "Western", "Wheat", "White", "Widowmaker", "Wind", "Window", "Wine", "Wolf", "Yellow", "Zeus", "Zombie", "Zoo"];

    const greekWords= [ "Προφορά", "Βελανίδι", "Αλαντίν", "Συναγερμός", "Αλκατράζ", "Αλκοόλ", "Εξωγήινος", "Συμμαχία", "Αμαζόνιος", "Ελλάδα", "Άγκυρα", "Άγγελος", "Επέτειος", "Ανταρκτική", "Μήλο", "Armstrong", "Αυστραλία", "Avatar", "Μωρό", "Αρτοποιός", "Φαλακρός", "Μπάλα", "Μπαλέτο", "Μπανάνα", "Συγκρότημα", "Μπαρ", "Μπάρμπεκιου", "Μπάρμπι", "Μπάνιο", "Μπάτμαν", "Μπαταρία", "Μπύρα", "Βέλγιο", "Αφαλός", "Ζώνη", "Βατόμουρο", "Στοίχημα", "Κυάλια", "Ξανθός", "Σανίδα", "Κόκκαλο", "Φωτιά", "Βιβλίο", "Αφεντικό", "Μπουκάλι", "Φιόγκος", "Μπόουλινγκ", "Μποξ", "Βραχιόλι", "Εγκέφαλος", "Κλαδί", "Ψωμί", "Γέφυρα", "Βούρτσα", "Φούσκα", "Βουγιουκλάκη", "Φασόλια", "Πεταλούδα", "Κουμπί", "Κάκτος", "Καίσαρας", "Καφετέρια", "Τούρτα", "Ημερολόγιο", "Καναδάς", "Καραμέλα", "Μπαστούνι", "Κανόνι", "Καντίνα", "Καμβάς", "Καρναβάλι", "Συγκρουόμενα", "Χαλί", "Χαρτόνι", "Καρτούν", "Καζίνο", "Κάστρο", "Γάτα", "Σαρανταποδαρούσα", "Σπηλιά", "Κουφάλα", "Κελί", "Νεκροταφείο", "Δημητριακά", "Αλυσίδα", "Σαμπάνια", "Τσένταρ", "Τυρί", "Chewbacca", "Κοτόπουλο", "Ιταλία", "Πατατάκι", "Σοκολάτα", "Χριστούγεννα", "Παπανδρέου", "Τσιγάρο", "Σταχτομπούτα", "Κινηματογράφος", "Τσίρκο", "Κλεοπάτρα", "Αναρρίχηση", "Τριφύλλι", "Ρόπαλο", "Κατσαρίδα", "Κοκτέιλ", "Κουκούλι", "Καφές", "Συνταγματάρχης", "Κωμωδία", "Πάπλωμα", "Υπολογιστής", "Συναυλία", "Μπισκότο", "Φελλός", "Γωνία", "Cougar", "Γερανός", "Κρέπα", "Κροκόδειλος", "Κρουασάν", "Σταυρός", "Σταυροδρόμι", "Κορώνα", "Κύβος", "Κούπα", "Έρως", "Κύκλος", "Χορός", "Δαρβίνος", "Δέκαθλο", "Άμυνα", "Οδοντίατρος", "Έρημος", "Διάβολος", "Διαμάντι", "Δεινόσαυρος", "Ντίσκο", "Γιατρός", "Κούκλα", "Doping", "Δράκουλας", "Drag", "Όνειρο", "Dune", "Νάνος", "Πάσχα", "Αυγό", "Ελαστικός", "Εκλογές", "Ηλεκτρισμός", "Ελέφαντας", "Ξωτικό", "Elvis", "Emergency", "Αυτοκράτορας", "Τέλος", "Απόγευμα", "Έβερεστ", "Έκρηξη", "Facebook", "Αποτυχία", "Πανηγύρι", "Νεράιδα", "Φθινόπωρο", "Χωράφι", "Μόδα", "Πυρετός", "Φωτιά", "Πυροτέχνημα", "Πυροσβέστης", "Fitzgerald", "Φλόγα", "Αστραπή", "Πτήση", "Flintstone", "Λουλούδι", "Φλάουτο", "Αφρός", "Ford", "Δάσος", "Πηρούνι", "Σιντριβάνι", "Αλεπού", "Γαλλία", "Φρανκενστάιν", "Παρασκευή", "Πατάτες", "Παγωνιά", "Γούνα", "Γαλαξίας", "Παιχνίδι", "Γκάντι", "Κήπος", "Σκόρδο", "Ιδιοφυΐα", "Φάντασμα", "Γίγαντας", "Μονομάχος", "Γυαλί", "Γυαλιά", "Στόχος", "Νονός", "Γκοτζίλα", "Γκολφ", "Google", "Gothic", "Γρασίδι", "Ελλάδα", "Gremlins", "Χειροβομβίδα", "Κιόσκι", "Φρουρός", "Γκιλοτίνα", "Gumbo", "Μαλλιά", "Κομμωτής", "Απόκριες", "Σφυρί", "Χερούλι", "Hanukkah", "Καπέλο", "Φουντούκι", "Καρδιά", "Φτέρνα", "Ελικόπτερο", "Κράνος", "Ιστορία", "Χόκει", "Τρύπα", "Χόλιγουντ", "Μέλι", "Λάστιχο", "Ξενοδοχείο", "Σπίτι", "Χουλκ", "Άνθρωπος", "Χιούμορ", "Κυνηγός", "Πάγος", "ΙΚΕΑ", "Ίριδα", "Σίδερο", "Νησί", "Ισραήλ", "Ιταλία", "Τζάκσον", "Τζεντάι", "Κοσμήματα", "Τζόκερ", "Καραγκιόζης", "Ζούγκλα", "Καράτε", "Βασιλιάς", "Μαχαίρι", "Ιππότης", "Σκάλα", "Πασχαλίτσα", "Λίμνη", "Λυχνάρι", "Γλώσσα", "Μεγάλος", "Λάβα", "Δικηγόρος", "Φύλλο", "Άλμα", "Λέγκο", "Γράμμα", "Φως", "Γλόμπος", "Φάρος", "Κεραυνός", "Άκρο", "Λιοντάρι", "Μόνος", "Λαχείο", "Μηχανή", "Τρελός", "Μαφία", "Μάγος", "Μαγνήτης", "Εγχειρίδιο", "Κοπριά", "Χάρτης", "Μάριο", "Αγορά", "Γάμος", "Άρης", "Μάσκα", "Μάτριξ", "Πεπόνι", "Μέταλλο", "Μεξικό", "Μίκι", "Microsoft", "Γάλα", "Μύλος", "Οφθαλμαπάτη", "Καθρέφτης", "Πύραυλος", "Μαΐμού", "Μονόπολη", "Φεγγάρι", "Μόσχα", "Κουνούπι", "Βουνό", "Ποντίκι", "Στόμα", "Χορτοκοπτικό", "Μότσαρτ", "Μούμια", "Μούσα", "Μανιτάρι", "Μουσική", "Σωματοφύλακας", "Μουστάκι", "Μουστάρδα", "Μύθος", "Νύχι", "Κολιέ", "Βελόνα", "Γειτονιά", "Φωλιά", "Νέος", "Εφημερίδα", "Νείλος", "Νίντζα", "Nintendo", "Νούντλ", "Πυρηνικός", "Αριθμός", "Καλόγρια", "Όαση", "Χταπόδι", "Ολυμπιακοί", "Όπερα", "Επέμβαση", "Όπρα", "Πορτοκάλι", "Φούρνος", "Πίνακας", "Ζευγάρι", "Παλάτι", "Τηγάνι", "Πάντα", "Αλεξίπτωτο", "Παράδεισος", "Παπαγάλος", "Πάθος", "Ειρήνη", "Ροδάκινο", "Φυστίκι", "Αχλάδι", "Βότσαλο", "Πιγκουΐνος", "Πιπέρι", "Άρωμα", "Πικάσο", "Πίτα", "Γουρούνι", "Περιστέρι", "Πίκατσου", "Μαξιλάρι", "Πιλότος", "Πιπεριά", "Σωλήνας", "Πειρατής", "Λάκκος", "Πίτσα", "Αεροπλάνο", "Πλαστικό", "Playstation", "Τανάλια", "Δηλητήριο", "Πόκερ", "Πολικός", "Πόλος", "Αστυνομία", "Πόνι", "Πισίνα", "Πάπας", "Πορσελάνη", "Πατάτα", "Πότερ", "Σκόνη", "Έγκυος", "Πρόεδρος", "Πρώτος", "Πριγκίπισσα", "Φυλακή", "Πανηγύρι", "Ψυχασθενής", "Αντλία", "Πανκ", "Μαριονέτα", "Τσάντα", "Πυραμίδα", "Ράδιο", "Σιδηρόδρομος", "Βροχή", "Τσουγκράνα", "Κριάρι", "Ράμπο", "Ραμσής", "Ραπ", "Αρουραίος", "Ακτίνα", "Ρέγκε", "Ταμείο", "Επανάσταση", "Δαχτυλίδι", "Ώριμος", "Ποτάμι", "Ρομπότ", "Πέτρα", "Ρόκι", "Δωμάτιο", "Κόκορας", "Ρίζα", "Σχοινί", "Τριαντάφυλλο", "Χάρακας", "Ρούμι", "Σαφάρι", "Χρηματοκιβώτιο", "Σαχάρα", "Sail", "Αλάτι", "Άμμος", "Λουκάνικο", "Ζυγαριά", "Σκηνή", "Σχολείο", "Βίδα", "Σειρά", "Υπόνομος", "Παράγκα", "Σέξπιρ", "Καρχαρίας", "Πρόβατο", "Ράφι", "Κοχύλι", "Σέρλοκ", "Πλοίο", "Φτυάρι", "Ντους", "Σρεκ", "Γαρίδα", "Simpson", "Σειρήνα", "Σκι", "Μανίκι", "Παντόφλα", "Καπνός", "Φίδι", "Χιόνι", "Σαπούνι", "Κάλτσα", "Πρίζα", "Καναπές", "Τραγιάσκα", "Τραγούδι", "Οδυσσέας", "Ακόντιο", "Καρύκευμα", "Λάνθιμος", "Κατάσκοπος", "Τράγος", "Αστέρι", "Goody's", "Μπουφές", "Σταθμός", "Ντολμάδες", "Κεντρί", "Πέτρα", "Καλαμάκι", "Φράουλα", "Κλωστή", "Γραφείο", "Γέμιση", "Υπόγειος", "Ζάχαρη", "Ήλιος", "Ελβετία", "Σπαθί", "Σιρόπι", "Τανγκό", "Ταραντίνο", "Ταρζάν", "Τατού", "Ταξί", "Ναός", "Τένις", "Ταξιτζής", "Θέατρο", "Σκέψη", "Νήμα", "Λαιμός", "Κεραυνός", "Εισιτήριο", "Γραβάτα", "Τίγρη", "Τιτανικός", "Καπνός", "Τόκιο", "Tolkien", "Ντομάτα", "Εργαλείο", "Κυκλώνας", "Πετσέτα", "Πύργος", "Παράδοση", "Τραίνο", "Θησαυρός", "Τρίγωνο", "Τροία", "Ανακωχή", "Σωλήνας", "Τουλίπα", "Τόνος", "Τούνελ", "Ομπρέλα", "Μονόκερως", "Στολή", "Διακοπές", "Βαμπίρ", "Βέγκας", "Λαχανικό", "Εκδίκηση", "Αφροδίτη", "Βίκινγκ", "Βιολί", "Ιός", "Ηφαίστειο", "Βαλς", "Πόλεμος", "Ρολόι", "Κύμα", "Καιρός", "Γουέστερν", "Σιτάρι", "Άσπρος", "Widowmaker", "Άνεμος", "Παράθυρο", "Κρασί", "Λύκος", "Κίτρινο", "Δίας", "Ζόμπι", "Μπιλιάρδο" ]

    // Seeded random number generator using mulberry32.
    function seededRandom(seed) {
      let state = seed;
      return function() {
        state = (state * 1664525 + 1013904223) >>> 0;
        let t = state;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    // Convert string seed to numeric value.
    function stringToSeed(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32-bit integer.
      }
      return Math.abs(hash);
    }

    // Fisher-Yates shuffle with seeded random.
    function shuffleArray(array, seed) {
      const arr = [...array]; // Copy array to avoid mutation.
      const random = seededRandom(seed);

      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }

      return arr;
    }

    const mainMenu = document.getElementById('mainMenu');
    const wordDisplay = document.getElementById('wordDisplay');
    const clueInput = document.getElementById('clueInput');
    const clueDisplay = document.getElementById('clueDisplay');
    const backBtn = document.getElementById('backBtn');
    const fsBtn = document.getElementById('fsBtn');
    const wordInner = document.getElementById('wordInner');
    const clueInner = document.getElementById('clueInner');
    const clueField = document.getElementById('clueField');

    // Use unified GameState from game.js
    const state = window.GameState;

    // Reconnection state for exponential backoff
    let reconnectAttempt = 0;
    let reconnectTimeout = null;

    // Message log for state synchronization
    const messageLog = [];

    // Streaming message queue for race condition prevention
    let processStreamingMessages = false;
    let streamingMessageQueue = [];

    // Generate unique message ID
    function generateMessageId() {
      return 'msg-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
    }

    // Extract the authoritative score from the message history.
    // Algorithm to prevent simultaneous scoring issues:
    // 1. Find the last endRound message
    // 2. Find the last newGame message BEFORE that endRound
    // 3. Find the first endRound message AFTER that newGame
    //
    // Why this is necessary: When multiple players score a round simultaneously,
    // they each send their own endRound message with potentially different scores
    // (due to network delays or race conditions). To ensure all players have
    // synchronized scores, we need to identify the authoritative endRound message
    // for each game session. The first endRound after a newGame is considered
    // authoritative, as it represents the first player to successfully score that round.
    // This prevents score desynchronization and ensures consistency across all clients.
    function extractAuthoritativeScore() {
      // Step 1: Find the last endRound message
      let lastEndRoundIndex = -1;
      for (let i = messageLog.length - 1; i >= 0; i--) {
        if (messageLog[i].type === 'endRound') {
          lastEndRoundIndex = i;
          break;
        }
      }

      // If no endRound found, we might be in the first round - return zero scores
      if (lastEndRoundIndex < 0) {
        return { totalScore: 0, totalGames: 0 };
      }

      // Step 2: Find the last newGame message BEFORE the last endRound
      let lastNewGameIndex = -1;
      for (let i = lastEndRoundIndex - 1; i >= 0; i--) {
        if (messageLog[i].type === 'newGame') {
          lastNewGameIndex = i;
          break;
        }
      }

      // If no newGame found before the endRound, the endRound might be from
      // a previous session or initial state. Use it as authoritative.
      if (lastNewGameIndex < 0) {
        const lastEndRound = messageLog[lastEndRoundIndex];
        if (lastEndRound.data) {
          return {
            totalScore: lastEndRound.data.totalScore !== undefined ? lastEndRound.data.totalScore : 0,
            totalGames: lastEndRound.data.totalGames !== undefined ? lastEndRound.data.totalGames : 0
          };
        }
        return { totalScore: 0, totalGames: 0 };
      }

      // Step 3: Find the FIRST endRound message AFTER that newGame
      // This is the authoritative endRound for that game session.
      let authoritativeEndRoundIndex = -1;
      for (let i = lastNewGameIndex + 1; i < messageLog.length; i++) {
        if (messageLog[i].type === 'endRound') {
          authoritativeEndRoundIndex = i;
          break;
        }
      }

      // If we found an authoritative endRound, use its score
      if (authoritativeEndRoundIndex >= 0) {
        const authoritativeEndRound = messageLog[authoritativeEndRoundIndex];
        if (authoritativeEndRound.data) {
          return {
            totalScore: authoritativeEndRound.data.totalScore !== undefined ? authoritativeEndRound.data.totalScore : 0,
            totalGames: authoritativeEndRound.data.totalGames !== undefined ? authoritativeEndRound.data.totalGames : 0
          };
        }
      }

      // Fallback: no endRound found after the newGame (game might still be in progress)
      return { totalScore: 0, totalGames: 0 };
    }

    // Filter messages based on rules:
    // - Messages within last 10 minutes
    // - Messages after last endRound message
    // - Exclude wordIndex messages
    function getFilteredMessages() {
      const tenMinutesAgo = Date.now() - (10 * 60 * 1000);

      // Find the index of the last endRound message
      let lastEndIndex = -1;
      for (let i = messageLog.length - 1; i >= 0; i--) {
        const msg = messageLog[i];
        if (msg.type === 'endRound') {
          lastEndIndex = i;
          break;
        }
      }

      // Filter messages based on rules
      const filtered = [];
      // Start from lastEndIndex (inclusive) to include the last endRound for notification purposes
      for (let i = Math.max(0, lastEndIndex); i < messageLog.length; i++) {
        const msg = messageLog[i];

        // Skip messages older than 10 minutes
        if (msg.timestamp < tenMinutesAgo) continue;

        // Skip wordIndex-only messages (newGame messages are included but wordIndex field ignored)
        // We keep the messages but will ignore the wordIndex field during replay

        filtered.push(msg);
      }

      return filtered;
    }

    // Replay messages to rebuild state
    function replayMessagesForState() {
      // Reset relevant state (but keep network info)
      state.game.word = '';
      state.network.userRole = null;
      state.submissions = [];

      // Clear active players
      activePlayers.clear();

      // Extract the authoritative score from message history
      const authoritativeScore = extractAuthoritativeScore();
      state.scoring.totalScore = authoritativeScore.totalScore;
      state.scoring.totalGames = authoritativeScore.totalGames;

      // Get filtered messages to replay
      const messages = getFilteredMessages();


      // Default to ENDED status if not offline (ready to start a new game).
      // This will be overridden if we replay a newGame message.
      if (state.network.status !== 'OFFLINE') {
        state.network.status = 'ENDED';
      }

      // Track if we're in a game
      let inGame = false;
      let gameWord = '';
      let gameLang = 'en';
      let wordHolder = null;

      // Process each message
      for (const msg of messages) {
        const isOwnMessage = msg.sender === state.network.clientId;

        switch (msg.type) {
          case 'newGame':
            inGame = true;
            gameWord = msg.data.word;
            gameLang = msg.data.lang || 'en';
            wordHolder = msg.sender;

            // Set state based on whether we're the word holder
            if (isOwnMessage) {
              state.network.userRole = 'wordHolder';
            } else {
              state.network.userRole = 'clueGiver';
            }

            state.game.word = gameWord;
            state.game.language = gameLang;
            state.network.status = 'IN_PROGRESS';

            // Clear submissions for new game
            state.submissions = [];
            break;

          case 'submitWord':
            if (inGame && msg.data.word) {
              const submission = {
                word: msg.data.word,
                user: msg.sender,
                username: msg.data.username || 'Anonymous'
              };

              // Check if not already added
              if (!state.submissions.some(s => s.word === submission.word && s.user === submission.user)) {
                state.submissions.push(submission);
              }
            }
            break;

          case 'playerJoined':
            // Track active player
            const username = msg.data.username || 'Anonymous';
            activePlayers.set(msg.sender, username);
            break;

          case 'endRound':
            // Check if this round was skipped
            const isSkipped = msg.data.skipped === true || msg.data.skipped === 'true';

            // Always use the totalScore and totalGames from the most recent endRound message
            // This ensures all players have synchronized scores
            if (msg.data.totalScore !== undefined) {
              state.scoring.totalScore = msg.data.totalScore;
            }
            if (msg.data.totalGames !== undefined) {
              state.scoring.totalGames = msg.data.totalGames;
            }

            // Show appropriate notification (only for recent messages, not during initial replay)
            const fiveSecondsAgo = Date.now() - 5000;
            if (msg.timestamp > fiveSecondsAgo) {
              if (isSkipped) {
                // Show skip notification
                showSkipNotification(msg.data.word, msg.data.username);
              } else if (msg.data.score !== undefined) {
                // Show score notification
                showScoreNotification(msg.data.score, msg.data.word, msg.data.username);
              }
            }

            // Update state for the end of round
            inGame = false;
            state.game.word = '';
            state.network.userRole = null;
            state.network.status = 'ENDED';
            state.submissions = [];
            activePlayers.clear();

            // Don't call resetToInitialState() here - just update state.
            // The UI reset should only happen when we're actually ending a round,
            // not when replaying messages.
            break;
        }
      }

      // Update displays based on replayed state
      updatePlayerCount();
      updateSubmittedWordsDisplay();
      updateButtonVisibility();
      updateScoreDisplay();

      // Check if we need to announce ourselves after replay
      // This handles the case where endRound cleared the player list
      if (state.network.roomCode && state.network.status !== "OFFLINE") {
        const hasOurPlayerJoined = messages.some(msg =>
          msg.type === 'playerJoined' && msg.sender === state.network.clientId
        );

        if (!hasOurPlayerJoined) {
          // We're not in the player list, announce ourselves.
          // This will only be sent once: sendGweetMessage adds the message to the log,
          // so the next replay will find our playerJoined message and won't send it again.
          sendGweetMessage({
            type: 'playerJoined'
          });
        }
      }
    }

    // Centralized state update function
    function updateGameState() {
      // Replay all messages to rebuild state
      replayMessagesForState();

      // If game is ended and player isn't in menu, force them back
      if (state.network.status === 'ENDED' && state.view.current !== 'menu') {
        // Reset everything to initial state when game has ended
        resetToInitialState();
      }
    }

    // Add message to log (without triggering state replay)
    function addMessageToLog(messageId, type, data, sender, timestamp = Date.now()) {
      // Check if message already exists (deduplication)
      if (messageLog.some(m => m.id === messageId)) {
        return false; // Message already exists
      }

      // Add to log
      messageLog.push({
        id: messageId,
        type: type,
        data: data || {},
        sender: sender,
        timestamp: timestamp
      });

      return true; // Message was added
    }

    // Language picker
    document.querySelectorAll('[name="lang"]').forEach(radio => {
      radio.addEventListener('change', e => {
        state.game.language = e.target.value;
      });
    });

    // Maximum Levenshtein distance to consider (configurable)
    const MAX_DISTANCE = 2;

    // Calculate Levenshtein distance between two strings (case-insensitive)
    // Returns distance up to MAX_DISTANCE, or Infinity if distance > MAX_DISTANCE
    function levenshteinDistance(string_a, string_b) {
      const a = string_a.toLowerCase();
      const b = string_b.toLowerCase();

      if (a.length === 0) return b.length > MAX_DISTANCE ? Infinity : b.length;
      if (b.length === 0) return a.length > MAX_DISTANCE ? Infinity : a.length;

      // Early exit if length difference > MAX_DISTANCE
      if (Math.abs(a.length - b.length) > MAX_DISTANCE) return Infinity;

      const matrix = [];

      // Initialize the first column (up to MAX_DISTANCE)
      for (let i = 0; i <= b.length; i++) {
        matrix[i] = [Math.min(i, MAX_DISTANCE + 1)];
      }

      // Initialize the first row (up to MAX_DISTANCE)
      for (let j = 0; j <= a.length; j++) {
        matrix[0][j] = Math.min(j, MAX_DISTANCE + 1);
      }

      // Calculate distances with early termination
      for (let i = 1; i <= b.length; i++) {
        let rowMin = Infinity;
        for (let j = 1; j <= a.length; j++) {
          if (b.charAt(i - 1) === a.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(
              matrix[i - 1][j - 1] + 1, // substitution
              matrix[i][j - 1] + 1,     // insertion
              matrix[i - 1][j] + 1      // deletion
            );
          }

          // Cap at MAX_DISTANCE + 1 (anything > MAX_DISTANCE is treated as infinity)
          if (matrix[i][j] > MAX_DISTANCE) {
            matrix[i][j] = MAX_DISTANCE + 1;
          }

          rowMin = Math.min(rowMin, matrix[i][j]);
        }

        // Early termination: if entire row > MAX_DISTANCE, result will be > MAX_DISTANCE
        if (rowMin > MAX_DISTANCE) {
          return Infinity;
        }
      }

      const distance = matrix[b.length][a.length];
      return distance > MAX_DISTANCE ? Infinity : distance;
    }


    // Generate room code
    function generateRoomCode() {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      let code = '';
      for (let i = 0; i < 4; i++) {
        code += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return code;
    }


    // Room management
    const roomBadge = document.getElementById('roomBadge');
    const roomModal = document.getElementById('roomModal');
    const roomCodeInput = document.getElementById('roomCodeInput');
    const nameInput = document.getElementById('nameInput');
    const submittedWordsDiv = document.getElementById('submittedWords');
    const wordsList = document.getElementById('wordsList');
    const currentWordDisplay = document.getElementById('currentWordDisplay');
    const endRoundBtn = document.getElementById('endRoundBtn');

    // Track unique players who have joined (store as Map of id -> username)
    const activePlayers = new Map();

    // Initialize button visibility and score display on load
    updateButtonVisibility();
    updateScoreDisplay();

    // Show room modal on load
    setTimeout(() => {
      // Parse URL parameters
      const urlParams = new URLSearchParams(window.location.search);
      const urlRoomCode = urlParams.get('room');

      // Load saved name from localStorage
      const savedName = localStorage.getItem('justone-username');
      if (savedName) {
        nameInput.value = savedName;
      }

      // Check if we have a valid room code in URL and a saved username
      if (urlRoomCode && /^[A-Za-z]{4}$/i.test(urlRoomCode) && savedName) {
        // Auto-join the room
        state.network.username = savedName;
        connectToRoom(urlRoomCode.toUpperCase());
      } else {
        // Show the room modal
        if (urlRoomCode && /^[A-Za-z]{4}$/i.test(urlRoomCode)) {
          // Pre-fill the room code from URL
          roomCodeInput.value = urlRoomCode.toUpperCase();
        }

        roomModal.classList.remove('hidden');
        // Focus on name input if empty, otherwise on room code
        if (!nameInput.value) {
          nameInput.focus();
        } else if (!roomCodeInput.value) {
          roomCodeInput.focus();
        } else {
          // Both filled, focus on join button or name field
          nameInput.focus();
        }
      }
    }, 100);

    // Room badge click handler
    roomBadge.addEventListener('click', () => {
      if (state.network.roomCode) {
        navigator.clipboard.writeText(state.network.roomCode).then(() => {
          const originalText = roomBadge.textContent;
          roomBadge.textContent = 'Copied!';
          setTimeout(() => {
            roomBadge.textContent = originalText;
          }, 1500);
        });
      }
    });

    // Join room button
    document.getElementById('joinRoomBtn').addEventListener('click', () => {
      const name = nameInput.value.trim();
      const code = roomCodeInput.value.toUpperCase();

      if (!name) {
        alert('Please enter your name');
        nameInput.focus();
        return;
      }

      if (!code || !/^[A-Z]{4}$/.test(code)) {
        alert('Please enter a valid 4-letter room code');
        roomCodeInput.focus();
        return;
      }

      state.network.username = name;
      localStorage.setItem('justone-username', name);
      connectToRoom(code);
    });

    // Handle Enter key in room code input
    roomCodeInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        document.getElementById('joinRoomBtn').click();
      }
    });

    // New room button
    document.getElementById('newRoomBtn').addEventListener('click', () => {
      const name = nameInput.value.trim();

      if (!name) {
        alert('Please enter your name');
        nameInput.focus();
        return;
      }

      state.network.username = name;
      localStorage.setItem('justone-username', name);
      const code = generateRoomCode();
      roomCodeInput.value = code;
      connectToRoom(code);
    });

    // Offline mode button
    document.getElementById('offlineBtn').addEventListener('click', () => {
      state.network.status = "OFFLINE";
      roomModal.classList.add('hidden');
      // Don't show the room badge in offline mode
      roomBadge.classList.add('hidden');
      // Clear player list in offline mode
      activePlayers.clear();
      updatePlayerCount();
      // Update button visibility for offline mode
      updateButtonVisibility();
      // Hide score display in offline mode
      updateScoreDisplay();

      // Clear any pending reconnection when going offline
      if (reconnectTimeout) {
        clearTimeout(reconnectTimeout);
        reconnectTimeout = null;
      }
      reconnectAttempt = 0;
    });

    // Connect to room
    function connectToRoom(code) {
      state.network.roomCode = code;
      roomBadge.textContent = `Room: ${code}`;
      roomBadge.classList.remove('hidden');
      roomModal.classList.add('hidden');

      // Connect to Gweet (will handle playerJoined automatically)
      connectToGweet();
    }

    // Helper function to schedule reconnection with exponential backoff
    function scheduleReconnect(errorMessage = null) {
      // Calculate backoff delay: 0ms (immediate), 1s, 2s, 5s, 5s, ...
      let retryDelay;
      if (reconnectAttempt === 0) {
        retryDelay = 0; // Immediate retry
      } else if (reconnectAttempt === 1) {
        retryDelay = 1000; // 1 second
      } else if (reconnectAttempt === 2) {
        retryDelay = 2000; // 2 seconds
      } else {
        retryDelay = 5000; // 5 seconds (max)
      }

      reconnectAttempt++;

      // Log reconnection details
      if (retryDelay === 0) {
        console.log('[Gweet] Retrying connection immediately...');
      } else {
        console.log(`[Gweet] Will retry connection in ${retryDelay / 1000} second${retryDelay > 1000 ? 's' : ''}...`);
      }

      // Show user-friendly error message (only after first attempt fails)
      if (reconnectAttempt > 1) {
        let errorMsg;
        if (errorMessage) {
          // Use custom error message for specific error conditions
          errorMsg = errorMessage;
          if (!errorMessage.includes('Retrying')) {
            errorMsg += retryDelay === 0 ? ' Retrying immediately...' : ` Retrying in ${retryDelay / 1000} second${retryDelay > 1000 ? 's' : ''}...`;
          }
        } else {
          // Default message for normal disconnection
          errorMsg = `Connection lost. ${retryDelay === 0 ? 'Retrying immediately...' : `Retrying in ${retryDelay / 1000} second${retryDelay > 1000 ? 's' : ''}...`}`;
        }
        showConnectionError(errorMsg, 6000);
      }

      // Schedule retry with backoff
      reconnectTimeout = setTimeout(() => {
        if (state.network.roomCode) {
          console.log('[Gweet] Executing scheduled reconnection...');
          connectToGweet();
        }
      }, retryDelay);
    }

    // Gweet connection management
    async function connectToGweet() {
      // Skip in offline mode
      if (state.isOffline()) return;

      console.log(`[Gweet] Attempting to connect to room: ${state.network.roomCode} (attempt #${reconnectAttempt + 1})`);

      // Reset streaming message processing flag and queue
      processStreamingMessages = false;
      streamingMessageQueue = [];

      // Disconnect existing connection and clear any pending reconnect
      if (state.network.controller) {
        state.network.controller.abort();
      }

      // Clear any pending reconnection timeout
      if (reconnectTimeout) {
        clearTimeout(reconnectTimeout);
        reconnectTimeout = null;
      }

      const channelKey = `justone-stavros-${state.network.roomCode.toLowerCase()}`;
      state.network.controller = new AbortController();

      try {
        // Fetch historical messages
        const historyResponse = await fetch(`https://gweet.stavros.io/stream/${channelKey}/?latest=50`);

        if (!historyResponse.ok) {
          throw new Error(`Failed to fetch messages: ${historyResponse.status} ${historyResponse.statusText}`);
        }

        const historyData = await historyResponse.json();

        // Process historical messages
        const tenMinutesAgo = new Date(Date.now() - 10 * 60 * 1000);
        if (historyData.messages) {
          // Process all historical messages through the message log system
          for (let i = 0; i < historyData.messages.length; i++) {
            const msg = historyData.messages[i];
            // Skip messages older than 10 minutes
            if (new Date(msg.created) < tenMinutesAgo) continue;

            // Pass message with timestamp
            const timestamp = new Date(msg.created).getTime();
            handleGweetMessage(msg.values, timestamp);
          }
        }

        // Process any streaming messages that arrived during historical fetch
        if (streamingMessageQueue.length > 0) {
          console.log(`[Gweet] Processing ${streamingMessageQueue.length} queued streaming messages`);

          // Sort queued messages by timestamp
          streamingMessageQueue.sort((a, b) => a.timestamp - b.timestamp);

          // Process each queued message
          for (const queuedMsg of streamingMessageQueue) {
            handleGweetMessage(queuedMsg.data, queuedMsg.timestamp);
          }

          // Clear the queue
          streamingMessageQueue = [];
        }

        // Now enable processing of new streaming messages
        processStreamingMessages = true;

        // Replay state once after all messages (historical + queued) are added
        updateGameState();

        // Establish streaming connection
        const streamResponse = await fetch(
          `https://gweet.stavros.io/stream/${channelKey}/?streaming=1`,
          { signal: state.network.controller.signal }
        );

        if (!streamResponse.ok) {
          throw new Error(`Failed to connect to stream: ${streamResponse.status} ${streamResponse.statusText}`);
        }

        // Connection successful - hide any existing errors and reset reconnect attempts
        console.log('[Gweet] Successfully connected to streaming endpoint');
        hideConnectionError();
        reconnectAttempt = 0;

        const reader = streamResponse.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';

        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            // Stream ended (connection closed)
            console.error('[Gweet] Streaming connection closed unexpectedly');
            break;
          }

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop(); // Keep incomplete line in buffer

          for (const line of lines) {
            if (line.trim()) {
              try {
                const data = JSON.parse(line);
                if (data.values) {
                  // Check if we should queue or process the message
                  if (!processStreamingMessages) {
                    // Queue the message with timestamp
                    const timestamp = data.created ? new Date(data.created).getTime() : Date.now();
                    streamingMessageQueue.push({
                      data: data.values,
                      timestamp: timestamp
                    });
                  } else {
                    // Process the message normally
                    handleGweetMessage(data.values);
                    // Replay state after receiving a real-time message
                    updateGameState();
                  }
                }
              } catch (e) {
                console.error('Error parsing message:', e);
              }
            }
          }
        }

        // If we reach here, the stream was closed
        console.error('[Gweet] Stream ended - connection was closed by the server');
        console.log('[Gweet] Will attempt to reconnect...');

        // Schedule reconnection when stream ends normally
        scheduleReconnect();
      } catch (error) {
        if (error.name !== 'AbortError') {
          console.error('[Gweet] Connection error:', error.message);

          // Build user-friendly error message based on error type
          let errorMsg = 'Unable to connect to Gweet server.';
          if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
            errorMsg = 'Unable to connect to Gweet server. Please check your internet connection.';
          } else if (error.message.includes('404')) {
            errorMsg = 'Room not found or expired.';
          } else if (error.message.includes('500') || error.message.includes('502') || error.message.includes('503')) {
            errorMsg = 'Server is temporarily unavailable.';
          }

          // Schedule reconnection with the error message
          scheduleReconnect(errorMsg);
        } else {
          console.log('[Gweet] Connection aborted intentionally');
        }
      }
    }

    // Error notification functions
    let errorTimeout = null;

    function showConnectionError(message, duration = 5000) {
      const errorDiv = document.getElementById('connectionError');
      const errorMessage = document.getElementById('errorMessage');

      // Clear any existing timeout
      if (errorTimeout) {
        clearTimeout(errorTimeout);
        errorTimeout = null;
      }

      errorMessage.textContent = message;
      errorDiv.classList.remove('hidden');

      // Auto-hide after duration (unless duration is 0 for persistent errors)
      if (duration > 0) {
        errorTimeout = setTimeout(() => {
          hideConnectionError();
        }, duration);
      }
    }

    function hideConnectionError() {
      const errorDiv = document.getElementById('connectionError');
      errorDiv.classList.add('hidden');

      if (errorTimeout) {
        clearTimeout(errorTimeout);
        errorTimeout = null;
      }
    }

    // Handle incoming Gweet messages
    function handleGweetMessage(data, timestamp) {
      let messageId, type, word, lang, user, username, wordIndex, score, totalScore, totalGames, skipped;

      // Parse message based on format
      if (typeof data === 'object' && data !== null) {
        messageId = data.messageId?.[0];
        type = data.type?.[0];
        word = data.word?.[0];
        lang = data.lang?.[0];
        user = data.user?.[0];
        username = data.username?.[0];
        wordIndex = data.wordIndex?.[0];
        // Parse scoring fields
        score = data.score?.[0];
        totalScore = data.totalScore?.[0];
        totalGames = data.totalGames?.[0];
        skipped = data.skipped?.[0];
      } else if (typeof data === 'string') {
        try {
          const jsonData = JSON.parse(data);
          if (jsonData.values) {
            return handleGweetMessage(jsonData.values, timestamp);
          }
        } catch {
          // Parse as URL-encoded
          const params = new URLSearchParams(data);
          messageId = params.get('messageId');
          type = params.get('type');
          word = params.get('word');
          lang = params.get('lang');
          user = params.get('user');
          username = params.get('username');
          wordIndex = params.get('wordIndex');
          // Parse scoring fields
          score = params.get('score');
          totalScore = params.get('totalScore');
          totalGames = params.get('totalGames');
          skipped = params.get('skipped');
        }
      }

      // If no message ID, generate one (for backward compatibility with older messages)
      if (!messageId) {
        messageId = 'legacy-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
      }

      // Track the highest word index seen (outside of message log)
      if (type === 'newGame' && wordIndex) {
        const idx = parseInt(wordIndex, 10);
        if (!isNaN(idx) && idx > state.game.wordIndex) {
          state.game.wordIndex = idx;
        }
      }

      // Build message data object
      const messageData = {};
      if (word) messageData.word = word;
      if (lang) messageData.lang = lang;
      if (username) messageData.username = username;
      // Include scoring fields
      if (score !== null && score !== undefined) {
        messageData.score = parseInt(score, 10);
      }
      if (totalScore !== null && totalScore !== undefined) {
        messageData.totalScore = parseInt(totalScore, 10);
      }
      if (totalGames !== null && totalGames !== undefined) {
        messageData.totalGames = parseInt(totalGames, 10);
      }
      if (skipped !== null && skipped !== undefined) {
        messageData.skipped = skipped;
      }
      // Note: wordIndex is deliberately not included in message data for replay

      // Add message to log (will trigger state replay)
      const wasAdded = addMessageToLog(
        messageId,
        type,
        messageData,
        user || 'unknown',
        timestamp || Date.now()
      );

      // Update language selector if needed
      if (state.game.language) {
        const langRadio = document.querySelector(`[name="lang"][value="${state.game.language}"]`);
        if (langRadio && !langRadio.checked) {
          langRadio.checked = true;
        }
      }
    }

    // Send message to Gweet
    async function sendGweetMessage(message) {
      if (!state.network.roomCode || state.network.status === "OFFLINE") return;

      // Generate unique message ID
      const messageId = generateMessageId();

      // Add message to local log immediately (except for endRound)
      // endRound messages should only be added when received from the server
      // to prevent race conditions with playerJoined messages
      const messageData = {
        ...message,
        username: state.network.username || 'Anonymous'
      };

      if (message.type !== 'endRound') {
        addMessageToLog(messageId, message.type, messageData, state.network.clientId);

        // Replay state after adding our own message
        updateGameState();
      }

      const channelKey = `justone-stavros-${state.network.roomCode.toLowerCase()}`;
      const params = new URLSearchParams();

      // Add message ID
      params.append('messageId', messageId);

      // Add user UUID to all messages
      params.append('user', state.network.clientId);

      // Add username to all messages
      if (state.network.username) {
        params.append('username', state.network.username);
      }

      // Add message fields
      for (const [key, value] of Object.entries(message)) {
        params.append(key, value);
      }

      try {
        const response = await fetch(`https://gweet.stavros.io/stream/${channelKey}/`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          body: params.toString()
        });

        if (!response.ok) {
          throw new Error(`Failed to send message: ${response.status} ${response.statusText}`);
        }

        // Hide any existing error when a message is successfully sent
        hideConnectionError();
      } catch (error) {
        console.error('Error sending message:', error);

        // Show user-friendly error message
        let errorMsg = 'Failed to send message. ';
        if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
          errorMsg += 'Please check your internet connection.';
        } else if (error.message.includes('500') || error.message.includes('502') || error.message.includes('503')) {
          errorMsg += 'Server is temporarily unavailable.';
        } else {
          errorMsg += 'Please try again.';
        }

        showConnectionError(errorMsg, 4000);
      }
    }

    // Update submitted words display
    function updateSubmittedWordsDisplay() {
      if (!state.hasSubmitted()) {
        submittedWordsDiv.classList.add('hidden');
        return;
      }

      // Show the submitted words div
      submittedWordsDiv.classList.remove('hidden');

      // Show the word display
      currentWordDisplay.classList.remove('hidden');
      currentWordDisplay.textContent = state.game.word ? `Word: ${state.game.word}` : '';

      // Clear and rebuild the list
      wordsList.innerHTML = '';

      // Get own submission for distance calculations
      const ownSubmission = state.getOwnSubmission();

      // Show own word first
      if (ownSubmission) {
        const li = document.createElement('li');
        li.textContent = `${ownSubmission.word} (You)`;
        li.className = 'own-word';
        wordsList.appendChild(li);
      }

      // Show other words with distance-based coloring
      state.submissions
        .filter(s => s.user !== state.network.clientId)
        .forEach(submission => {
          const li = document.createElement('li');
          const displayName = submission.username || 'Anonymous';
          li.textContent = `${submission.word} (${displayName})`;

          // Calculate minimum distance from this word to all other words
          let minDistance = Infinity;

          // Compare against all other submissions (including own)
          state.submissions.forEach(otherSubmission => {
            if (otherSubmission !== submission) {
              const distance = levenshteinDistance(submission.word, otherSubmission.word);
              minDistance = Math.min(minDistance, distance);
            }
          });

          // Apply appropriate class based on minimum distance
          if (minDistance <= MAX_DISTANCE) {
            li.className = `distance-${minDistance}`;
          }
          // Distance > MAX_DISTANCE gets default grey background from base .word-list li style

          wordsList.appendChild(li);
        });
    }

    // Show Clue button handler
    document.getElementById('showClueBtn').addEventListener('click', () => {
      // Hide the modal
      submittedWordsDiv.classList.add('hidden');

      // Get the user's own submission and set it as the clue
      const ownSubmission = state.getOwnSubmission();
      if (ownSubmission) {
        clueInner.textContent = ownSubmission.word;
      }

      // Show the clue in fullscreen
      show('clue');
      enterFullscreen();
      fitText(clueInner);
      setTimeout(() => fitText(clueInner), 100);
    });

    // Update score display
    function updateScoreDisplay() {
      const scoreDisplay = document.getElementById('scoreDisplay');
      const scoreValue = document.getElementById('scoreValue');
      const gamesValue = document.getElementById('gamesValue');

      // Hide score display in offline mode
      if (state.network.status === "OFFLINE") {
        scoreDisplay.style.display = 'none';
      } else {
        scoreDisplay.style.display = 'block';
        if (scoreValue && gamesValue) {
          scoreValue.textContent = state.scoring.totalScore;
          gamesValue.textContent = state.scoring.totalGames;
        }
      }
    }

    // Show score notification
    function showScoreNotification(score, word, scoredBy) {
      const notification = document.getElementById('scoreNotification');
      const text = document.getElementById('scoreNotificationText');

      let message = '';
      let className = '';

      if (score === 1) {
        message = `✓ Correct! +1 point`;
        className = 'success';
      } else if (score === 0) {
        message = `→ Pass! No points`;
        className = 'neutral';
      } else if (score === -1) {
        message = `✗ Failed! -1 point`;
        className = 'fail';
      }

      if (word) {
        message += ` (${word})`;
      }

      if (scoredBy) {
        message += ` - scored by ${scoredBy}`;
      }

      text.textContent = message;
      notification.className = `score-notification ${className}`;
      notification.classList.remove('hidden');

      // Auto-hide after 4 seconds
      setTimeout(() => {
        notification.classList.add('hidden');
      }, 4000);
    }

    // Show skip notification
    function showSkipNotification(word, skippedBy) {
      const notification = document.getElementById('scoreNotification');
      const text = document.getElementById('scoreNotificationText');

      let message = '⊘ Round skipped - not counted';

      if (word) {
        message += ` (${word})`;
      }

      if (skippedBy) {
        message += ` - skipped by ${skippedBy}`;
      }

      text.textContent = message;
      notification.className = 'score-notification neutral';
      notification.classList.remove('hidden');

      // Auto-hide after 4 seconds
      setTimeout(() => {
        notification.classList.add('hidden');
      }, 4000);
    }

    // Update player count display
    function updatePlayerCount() {
      const playerCountDiv = document.getElementById('playerCount');
      const playerListItems = document.getElementById('playerListItems');
      const playerListContainer = document.getElementById('playerList');
      const count = activePlayers.size;

      if (state.network.status === "OFFLINE") {
        playerListContainer.style.display = 'none';
      } else {
        playerListContainer.style.display = 'block';

        if (count === 0) {
          playerCountDiv.textContent = 'Waiting for players...';
          playerListItems.innerHTML = '';
        } else {
          playerCountDiv.textContent = `Players in lobby (${count})`;

          // Clear and rebuild the player list
          playerListItems.innerHTML = '';

          // Add each player as a list item
          activePlayers.forEach((username, userId) => {
            const li = document.createElement('li');
            li.textContent = username;

            // Mark the current user
            if (userId === state.network.clientId) {
              li.classList.add('current-player');
              li.textContent += ' (You)';
            }

            playerListItems.appendChild(li);
          });
        }
      }
    }

    // Scoring modal functions
    function showScoringModal() {
      const modal = document.getElementById('scoringModal');
      const wordDiv = document.getElementById('scoringWord');

      // Show the word being scored
      wordDiv.textContent = state.game.word ? `Word was: ${state.game.word}` : '';

      modal.classList.remove('hidden');
    }

    function hideScoringModal() {
      const modal = document.getElementById('scoringModal');
      modal.classList.add('hidden');
    }

    function endRoundWithScore(score) {
      // Calculate new totals
      const newTotalScore = state.scoring.totalScore + score;
      const newTotalGames = state.scoring.totalGames + 1;

      // Update state immediately
      state.scoring.totalScore = newTotalScore;
      state.scoring.totalGames = newTotalGames;

      // Update score display
      updateScoreDisplay();

      // Show notification
      showScoreNotification(score, state.game.word, state.network.username || 'You');

      // Send endRound message with scoring data (if online)
      if (!state.isOffline()) {
        sendGweetMessage({
          type: 'endRound',
          score: score,
          totalScore: newTotalScore,
          totalGames: newTotalGames,
          word: state.game.word
        });
      }

      // Reset everything to initial state
      resetToInitialState();
    }

    // Skip round function - doesn't affect score or game count
    function skipRound() {
      // Show skip notification to the player who skipped
      showSkipNotification(state.game.word, 'You');

      // Send endRound message with skipped flag (if online)
      if (!state.isOffline()) {
        sendGweetMessage({
          type: 'endRound',
          skipped: true,
          totalScore: state.scoring.totalScore,  // Send current score unchanged
          totalGames: state.scoring.totalGames,  // Send current games unchanged
          word: state.game.word
        });
      }

      // Reset everything to initial state
      resetToInitialState();
    }

    // Scoring button handlers
    document.getElementById('correctBtn').addEventListener('click', () => endRoundWithScore(1));
    document.getElementById('passBtn').addEventListener('click', () => endRoundWithScore(0));
    document.getElementById('failBtn').addEventListener('click', () => endRoundWithScore(-1));
    document.getElementById('skipRoundBtn').addEventListener('click', skipRound);
    document.getElementById('cancelScoringBtn').addEventListener('click', hideScoringModal);

    // End Round button handler
    endRoundBtn.addEventListener('click', () => {
      // Show scoring modal instead of confirmation
      showScoringModal();
    });

    // View management
    function show(view) {
      [mainMenu, wordDisplay, clueInput, clueDisplay].forEach(v => v.classList.add('hidden'));

      if (view === 'menu') {
        backBtn.classList.add('hidden');
      } else {
        backBtn.classList.remove('hidden');
      }

      switch(view) {
        case 'menu': mainMenu.classList.remove('hidden'); break;
        case 'word': wordDisplay.classList.remove('hidden'); break;
        case 'clueIn': clueInput.classList.remove('hidden'); break;
        case 'clue': clueDisplay.classList.remove('hidden'); break;
      }
      state.view.current = view;

      // Update all button visibility based on current state
      updateButtonVisibility();

      // Update browser history for back button handling
      if (view !== 'menu') {
        history.pushState({ view: view }, '', '#' + view);
      } else {
        history.replaceState({ view: 'menu' }, '', window.location.pathname);
      }
    }

    // Auto fullscreen helper
    function enterFullscreen() {
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
      if (!isIOS && document.documentElement.requestFullscreen && !document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(() => {});
      }
    }


    // Centralized function to reset everything to initial state when a round ends.
    function resetToInitialState() {
      // Reset game state using the GameState reset method
      state.reset();

      // Clear word displays
      wordInner.textContent = '';
      clueInner.textContent = '';
      clueField.value = '';

      // Remove blur effects
      wordInner.classList.remove('blurred');
      wordText.classList.remove('word-blurred');

      // Hide all views and show main menu
      wordDisplay.classList.add('hidden');
      clueInput.classList.add('hidden');
      clueDisplay.classList.add('hidden');
      submittedWordsDiv.classList.add('hidden');
      mainMenu.classList.remove('hidden');

      // Set view state to menu
      state.view.current = 'menu';

      // Clear countdown display if it exists
      const countdownDisplay = document.getElementById('countdownDisplay');
      if (countdownDisplay) {
        countdownDisplay.textContent = '';
      }

      // Update history state to menu
      history.replaceState({ view: 'menu' }, '', window.location.pathname);

      // Update button visibility
      updateButtonVisibility();

      // Clear submitted words list
      wordsList.innerHTML = '';
      currentWordDisplay.textContent = '';
      currentWordDisplay.classList.add('hidden');

      // Hide scoring modal if visible
      hideScoringModal();

      // Exit fullscreen if active
      if (document.fullscreenElement) {
        document.exitFullscreen().catch(() => {});
      }

      // Update back button visibility
      backBtn.classList.add('hidden');
    }

    // Update button visibility based on user role and game state
    function updateButtonVisibility() {
      const btnWord = document.getElementById('btnWord');
      const btnClue = document.getElementById('btnClue');

      // Simplified button state logic
      const isOffline = state.network.status === "OFFLINE";
      const isInProgress = state.network.status === "IN_PROGRESS";
      const isWordHolder = state.network.userRole === 'wordHolder';
      const isClueGiver = state.network.userRole === 'clueGiver';

      // Set button states
      btnWord.classList.toggle('disabled',
        !isOffline && isInProgress && !isWordHolder);
      btnClue.classList.toggle('disabled',
        !isOffline && (state.network.status === "ENDED" || (isInProgress && !isClueGiver)));

      // End Round button visibility
      const showEndRound = isInProgress && !isOffline &&
        (state.view.current === 'menu' || state.view.current === 'word' || state.view.current === 'clue' ||
         !submittedWordsDiv.classList.contains('hidden'));
      endRoundBtn.classList.toggle('hidden', !showEndRound);
    }

    // Get Word button
    document.getElementById('btnWord').onclick = () => {
      // In offline mode, always allow getting a new word
      if (state.network.status === "OFFLINE") {
        const pool = state.game.language === 'en' ? englishWords : greekWords;
        // For offline mode, just pick randomly.
        state.game.word = pool[Math.floor(Math.random() * pool.length)];

        show('word');
        enterFullscreen();

        let seconds = 2;
        wordInner.textContent = seconds;
        fitText(wordInner);
        state.game.wordDisplay = 'countdown';

        if (state.game.countdownTimer) clearInterval(state.game.countdownTimer);
        state.game.countdownTimer = setInterval(() => {
          seconds--;
          if (seconds <= 0) {
            clearInterval(state.game.countdownTimer);
            state.game.countdownTimer = null;
            wordInner.textContent = state.game.word;
            state.game.wordDisplay = 'visible';
          } else {
            wordInner.textContent = seconds;
          }
          fitText(wordInner);
        }, 1000);
        return;
      }

      // Check if user is the word holder returning to their word
      if (state.network.status === "IN_PROGRESS" && state.network.userRole === 'wordHolder') {
        // Return to the existing word
        show('word');
        enterFullscreen();
        wordInner.textContent = state.game.word;
        state.game.wordDisplay = 'visible';
        fitText(wordInner);
        return;
      }

      // Check if a game is already in progress (and user is not word holder)
      if (state.network.status === "IN_PROGRESS") {
        // Button should be disabled for clue givers
        return;
      }

      // Start a new game
      const pool = state.game.language === 'en' ? englishWords : greekWords;
      // Use room code as seed for deterministic shuffling.
      const seed = stringToSeed(state.network.roomCode.toUpperCase());
      const shuffled = shuffleArray(pool, seed);

      // Use current index, then increment for next time.
      const currentIndex = state.game.wordIndex;
      const newWord = shuffled[currentIndex % shuffled.length];
      state.game.wordIndex = currentIndex + 1;

      // Send new game message (this will update state through the message log)
      sendGweetMessage({
        type: 'newGame',
        word: newWord,
        lang: state.game.language,
        wordIndex: state.game.wordIndex  // Send the updated index
      });

      show('word');
      enterFullscreen(); // Auto enter fullscreen

      let seconds = 2;
      wordInner.textContent = seconds;
      fitText(wordInner);
      state.game.wordDisplay = 'countdown';

      if (state.game.countdownTimer) clearInterval(state.game.countdownTimer);
      state.game.countdownTimer = setInterval(() => {
        seconds--;
        if (seconds <= 0) {
          clearInterval(state.game.countdownTimer);
          state.game.countdownTimer = null;
          wordInner.textContent = state.game.word;
          state.game.wordDisplay = 'visible';
        } else {
          wordInner.textContent = seconds;
        }
        fitText(wordInner);
      }, 1000);
    };

    // Create hold progress indicator
    const createProgressIndicator = () => {
      const indicator = document.createElement('div');
      indicator.className = 'hold-progress';
      indicator.id = 'holdProgress';

      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('viewBox', '0 0 100 100');

      // Background circle
      const bgCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      bgCircle.setAttribute('cx', '50');
      bgCircle.setAttribute('cy', '50');
      bgCircle.setAttribute('r', '40');
      bgCircle.className = 'hold-progress-background';

      // Progress circle
      const progressCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      progressCircle.setAttribute('cx', '50');
      progressCircle.setAttribute('cy', '50');
      progressCircle.setAttribute('r', '40');
      progressCircle.className = 'hold-progress-ring';
      progressCircle.id = 'holdProgressRing';

      // Set up stroke dasharray for progress animation
      const circumference = 2 * Math.PI * 40;
      progressCircle.style.strokeDasharray = `${circumference} ${circumference}`;
      progressCircle.style.strokeDashoffset = circumference;

      svg.appendChild(bgCircle);
      svg.appendChild(progressCircle);
      indicator.appendChild(svg);
      document.body.appendChild(indicator);

      return { indicator, progressCircle, circumference };
    };

    const { indicator: holdIndicator, progressCircle, circumference } = createProgressIndicator();

    // Word screen hold-to-blur functionality
    const wordText = document.getElementById('wordText');
    let holdStartTime = 0;

    // Create and play blur sound
    let audioContext = null;
    const playBlurSound = () => {
      // Create a simple beep sound using Web Audio API
      try {
        // Initialize AudioContext on first use (iOS requirement)
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }

        // Resume AudioContext if it's suspended (iOS requirement)
        if (audioContext.state === 'suspended') {
          audioContext.resume();
        }

        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.frequency.setValueAtTime(800, audioContext.currentTime); // 800 Hz tone
        oscillator.type = 'sine';

        gainNode.gain.setValueAtTime(1.0, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.1, audioContext.currentTime + 0.2);

        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.2);
      } catch (e) {
        // Fallback: try to use a data URI for a simple beep
        try {
          const audio = new Audio("data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuE0e/cdi4HKW/A7+dV");
          audio.volume = 1.0;
          audio.play().catch(e => console.log('Audio play failed:', e));
        } catch (e2) {
          console.log('Audio playback not supported');
        }
      }
    };

    const startHold = () => {
      if (state.view.current !== 'word') {
        return;
      }

      // If currently visible, blur immediately without hold
      if (state.game.wordDisplay === 'visible') {
        state.game.wordDisplay = 'blurred';
        wordInner.classList.add('blurred');
        wordText.classList.add('word-blurred');

        // Play blur sound
        playBlurSound();

        // Haptic feedback
        if (navigator.vibrate) {
          navigator.vibrate(50);
        }
        return;
      }

      // Only require hold when unblurring (blurred -> visible)
      if (state.game.wordDisplay !== 'blurred') {
        return;
      }

      // Clean up any existing hold state
      if (state.game.holdTimer) {
        clearTimeout(state.game.holdTimer);
      }
      if (state.game.holdAnimationFrame) {
        cancelAnimationFrame(state.game.holdAnimationFrame);
      }

      state.game.isHolding = true;
      state.game.holdProgress = 0;
      holdStartTime = Date.now();

      // Show progress indicator with pulse animation
      holdIndicator.classList.add('active', 'pulse');
      setTimeout(() => holdIndicator.classList.remove('pulse'), 300);

      // Start progress animation
      const animateProgress = () => {
        if (!state.game.isHolding) return;

        const elapsed = Date.now() - holdStartTime;
        const progress = Math.min(elapsed / 500, 1); // 500ms hold duration
        state.game.holdProgress = progress * 100;

        // Update progress ring
        const offset = circumference - (progress * circumference);
        progressCircle.style.strokeDashoffset = offset;

        if (progress < 1) {
          state.game.holdAnimationFrame = requestAnimationFrame(animateProgress);
        } else {
          // Hold complete - toggle blur
          completeHold();
        }
      };

      state.game.holdAnimationFrame = requestAnimationFrame(animateProgress);

      // Set timeout as backup for completion
      state.game.holdTimer = setTimeout(() => {
        if (state.game.isHolding) {
          completeHold();
        }
      }, 500);
    };

    const cancelHold = () => {
      if (!state.game.isHolding) return;

      state.game.isHolding = false;
      state.game.holdProgress = 0;

      // Clean up timers
      if (state.game.holdTimer) {
        clearTimeout(state.game.holdTimer);
        state.game.holdTimer = null;
      }
      if (state.game.holdAnimationFrame) {
        cancelAnimationFrame(state.game.holdAnimationFrame);
        state.game.holdAnimationFrame = null;
      }

      // Hide and reset progress indicator
      holdIndicator.classList.remove('active');
      progressCircle.style.strokeDashoffset = circumference;
    };

    const completeHold = () => {
      if (!state.game.isHolding) return;

      // Unblur the word (hold is only for unblurring)
      state.game.wordDisplay = 'visible';
      wordInner.classList.remove('blurred');
      wordText.classList.remove('word-blurred');

      // Haptic feedback
      if (navigator.vibrate) {
        navigator.vibrate(50);
      }

      // Clean up
      cancelHold();
    };

    // Mouse events
    wordText.addEventListener('mousedown', (e) => {
      e.preventDefault();
      startHold();
    });

    wordText.addEventListener('mouseup', cancelHold);
    wordText.addEventListener('mouseleave', cancelHold);

    // Touch events
    wordText.addEventListener('touchstart', (e) => {
      e.preventDefault();
      startHold();
    });

    wordText.addEventListener('touchend', (e) => {
      e.preventDefault();
      cancelHold();
    });

    wordText.addEventListener('touchcancel', cancelHold);

    // Cancel hold if view changes
    const originalShow = show;
    show = (viewName) => {
      cancelHold();
      originalShow(viewName);
    };

    // Type Clue button
    document.getElementById('btnClue').onclick = () => {
      // In offline mode, always allow typing a clue
      if (state.network.status === "OFFLINE") {
        clueField.value = '';
        show('clueIn');
        // Focus the input field after the view is shown
        requestAnimationFrame(() => {
          clueField.focus();
          // For mobile devices, also scroll into view
          clueField.scrollIntoView({ behavior: 'smooth', block: 'center' });
        });
        return;
      }

      // Check if not in a game or not a clue giver
      if (state.network.status !== "IN_PROGRESS" || state.network.userRole !== 'clueGiver') {
        return;
      }

      // If user has already submitted a word, show the submitted words modal
      if (state.hasSubmitted()) {
        show('clueIn');
        updateSubmittedWordsDisplay();
      } else {
        // Show clue input for new submission
        clueField.value = '';
        show('clueIn');
        // Focus the input field after the view is shown
        requestAnimationFrame(() => {
          clueField.focus();
          // For mobile devices, also scroll into view
          clueField.scrollIntoView({ behavior: 'smooth', block: 'center' });
        });
      }
    };

    // Prevent spaces in clue field (allow all other characters including emojis)
    clueField.addEventListener('keydown', (e) => {
      // Prevent space key (keyCode 32)
      if (e.keyCode === 32) {
        e.preventDefault();
      }
    });

    clueField.addEventListener('input', (e) => {
      // Remove any spaces from the input
      e.target.value = e.target.value.replace(/\s/g, '');
    });

    // Clue form submission
    document.getElementById('clueForm').addEventListener('submit', e => {
      e.preventDefault();
      const val = clueField.value.trim();
      if (!val) return;
      if (/\s/.test(val)) { alert('One word only!'); return; }

      // In offline mode, go straight to showing the clue
      if (state.network.status === "OFFLINE") {
        clueInner.textContent = val;
        show('clue');
        enterFullscreen();
        fitText(clueInner);
        setTimeout(() => fitText(clueInner), 100);
        return;
      }

      // Check if there's a word in the channel
      if (!state.game.word) {
        alert('No word to give a clue for! Someone needs to start a new game first.');
        return;
      }

      // Send the submitted word to other players
      sendGweetMessage({
        type: 'submitWord',
        word: val
      });

      // Note: The submission will be added to state via the message log when sendGweetMessage processes it

      // Show the submitted words modal instead of going directly to clue display
      updateSubmittedWordsDisplay();

      // Stay in clueIn view with the modal on top
      // The modal will be shown by updateSubmittedWordsDisplay
    });

    // Handle browser back button/gesture
    function goBackToMenu() {
      // No confirmation needed since we're preserving state

      if (state.game.countdownTimer) {
        clearInterval(state.game.countdownTimer);
        state.game.countdownTimer = null;
      }

      // Reset blur state but keep the word (don't clear it)
      if (state.view.current === 'word') {
        if (state.game.wordDisplay === 'blurred') {
          state.game.wordDisplay = 'visible';
          wordInner.classList.remove('blurred');
          document.getElementById('wordText').classList.remove('word-blurred');
        }
      }

      // Hide submitted words modal when returning to menu
      submittedWordsDiv.classList.add('hidden');

      show('menu');
    }

    // Back button
    backBtn.onclick = () => {
      goBackToMenu();
    };

    // Handle browser back button/swipe navigation
    window.addEventListener('popstate', (event) => {
      // Show confirmation for word screen, always go back for other screens
      goBackToMenu();
    });

    // Event listeners for dynamic resizing
    window.addEventListener('resize', () => {
      if (state.view.current === 'word') fitText(wordInner);
      if (state.view.current === 'clue') fitText(clueInner);
    });

    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        if (state.view.current === 'word') fitText(wordInner);
        if (state.view.current === 'clue') fitText(clueInner);
      }, 100);
    });

    // Fullscreen functionality
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);

    if (!document.documentElement.requestFullscreen || isIOS) {
      fsBtn.style.display = 'none';
    } else {
      function updateFSIcon() {
        fsBtn.textContent = document.fullscreenElement ? '🗗' : '⛶';
      }
      fsBtn.addEventListener('click', () => {
        if (document.fullscreenElement) {
          document.exitFullscreen?.();
        } else {
          document.documentElement.requestFullscreen().catch(() => {});
        }
      });
      document.addEventListener('fullscreenchange', updateFSIcon);
      updateFSIcon();
    }

    // Confirmation when navigating away during active game
    window.addEventListener('beforeunload', (e) => {
      // Show confirmation if game is in progress (not in offline mode or ended state)
      if (state.network.status === "IN_PROGRESS") {
        // Cancel the event as stated by the standard
        e.preventDefault();
        // Chrome requires returnValue to be set
        e.returnValue = '';
        // Return a string for older browsers
        return 'Are you sure you want to leave? A game is currently in progress.';
      }
    });
  </script>
</body>
</html>
