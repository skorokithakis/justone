<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#ffb3ba">
  <link rel="manifest" href="./manifest.json">
  <link rel="icon" type="image/png" sizes="192x192" href="./icon-192.png">
  <link rel="apple-touch-icon" href="./icon-192.png">
  <title>Just One Helper</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=LXGW+WenKai+Mono+TC&display=swap" rel="stylesheet">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    html, body {
      height: 100%;
      width: 100%;
      overflow: hidden;
      background: #f8f9fa;
      font-family: "LXGW WenKai Mono TC", monospace;
      -webkit-user-select: none;
      user-select: none;
      position: fixed;
      top: 0;
      left: 0;
    }
    
    #app {
      width: 100dvw;
      height: 100dvh;
      display: flex;
      flex-direction: column;
      position: relative;
      overflow: hidden;
    }
    
    .hidden { display: none !important; }
    
    /* Main Menu */
    #mainMenu {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 2rem;
      padding: 2rem;
    }
    
    /* Room Join Screen */
    #roomJoin {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 2rem;
      padding: 2rem;
    }
    
    #roomCodeDisplay {
      text-align: center;
    }
    
    #roomCodeDisplay h2 {
      font-size: 1.5rem;
      margin-bottom: 1rem;
      color: #2c3e50;
    }
    
    #roomCode {
      font-size: 3rem;
      font-weight: bold;
      color: #ffb3ba;
      letter-spacing: 0.5rem;
      text-transform: uppercase;
    }
    
    #roomJoinForm {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }
    
    #roomJoinForm label {
      font-size: 1.2rem;
      color: #2c3e50;
    }
    
    #roomCodeInput {
      font-family: "LXGW WenKai Mono TC", monospace;
      font-size: 2rem;
      text-transform: uppercase;
      text-align: center;
      padding: 0.5rem 1rem;
      border: 3px solid #ffb3ba;
      border-radius: 12px;
      width: 200px;
      letter-spacing: 0.3rem;
    }
    
    /* Words List Display */
    #wordsList {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      padding: 2rem;
      overflow-y: auto;
    }
    
    #wordsListHeader {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    #wordsListHeader h2 {
      font-size: 1.5rem;
      color: #2c3e50;
      margin-bottom: 0.5rem;
    }
    
    #currentWord {
      font-size: 2rem;
      font-weight: bold;
      color: #ffb3ba;
      margin-bottom: 1rem;
    }
    
    #wordsGrid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 1rem;
      margin-bottom: 2rem;
    }
    
    .wordItem {
      background: #ffb3ba;
      color: #2c3e50;
      padding: 1rem;
      border-radius: 12px;
      text-align: center;
      font-size: 1.2rem;
      cursor: pointer;
      transition: background 0.25s;
    }
    
    .wordItem:hover {
      background: #ffc9c9;
    }
    
    .wordItem.own {
      background: #ff9aa2;
      font-weight: bold;
    }
    
    #newGameBtn {
      margin-top: auto;
    }
    
    #langPicker {
      display: flex;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    
    #langPicker label {
      font-size: 1.2rem;
      cursor: pointer;
    }
    
    button {
      font-family: "LXGW WenKai Mono TC", monospace;
      font-size: 1.5rem;
      padding: 1rem 2rem;
      border: none;
      border-radius: 12px;
      background: #ffb3ba;
      color: #2c3e50;
      cursor: pointer;
      transition: background 0.25s;
      touch-action: manipulation;
      min-height: 44px;
      min-width: 44px;
    }
    
    button:hover, button:active {
      background: #ffc9c9;
    }
    
    /* Fullscreen Text Views */
    .fullscreenView {
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      color: #2c3e50;
      font-family: "LXGW WenKai Mono TC", monospace;
      line-height: 1.1;
      overflow: hidden;
      position: absolute;
      top: 0;
      left: 0;
    }
    
    .fullscreenView span {
      display: block;
      font-size: 4rem;
      max-width: 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    /* Clue Input */
    #clueInput {
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 2rem;
    }
    
    #clueForm {
      width: 100%;
      max-width: 500px;
    }
    
    .input-container {
      position: relative;
      width: 100%;
      border: 3px solid #ffb3ba;
      border-radius: 12px;
      overflow: hidden;
      background: white;
      height: 70px;
    }
    
    #clueField {
      font-family: "LXGW WenKai Mono TC", monospace;
      font-size: 1.5rem;
      width: 100%;
      height: 100%;
      text-align: center;
      padding: 1rem 70px 1rem 1rem;
      border: none;
      outline: none;
      background: white;
      box-sizing: border-box;
    }
    
    #submitBtn {
      position: absolute;
      top: 0;
      right: 0;
      font-size: 1.5rem;
      padding: 0;
      border: none;
      background: #ffb3ba;
      color: #2c3e50;
      cursor: pointer;
      transition: background 0.25s;
      border-radius: 0;
      width: 60px;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    #submitBtn:hover, #submitBtn:active {
      background: #ffc9c9;
    }

    #wordInner,
    #clueInner {
      font-weight: 900;
    }
    
    /* Blur effect for word text */
    #wordText {
        transition: background 0.3s ease;
    }

    .blurred {
      filter: blur(60px);
      transition: filter 0.3s ease;
    }
    
    /* Gray background when word is blurred */
    .word-blurred {
      background: #ff9aa2;
    }
    
    /* Back Button */
    #backBtn {
      position: fixed;
      top: 1rem;
      left: 1rem;
      font-size: 1.5rem;
      border-radius: 50%;
      background: #ff9aa2;
      z-index: 10;
      width: 44px;
      height: 44px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    #backBtn.hidden {
      display: none;
    }
    
    /* Room Code Badge */
    #roomCodeBadge {
      position: fixed;
      bottom: 1rem;
      left: 1rem;
      background: #ffb3ba;
      color: #2c3e50;
      padding: 0.5rem 1rem;
      border-radius: 12px;
      font-size: 1.2rem;
      font-weight: bold;
      letter-spacing: 0.1rem;
      z-index: 10;
      text-transform: uppercase;
    }
    
    #roomCodeBadge.hidden {
      display: none;
    }
    
    /* Fullscreen Button */
    #fsBtn {
      position: fixed;
      top: 1rem;
      right: 1rem;
      font-size: 1.5rem;
      border-radius: 50%;
      background: #ff9aa2;
      z-index: 10;
      width: 44px;
      height: 44px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="roomJoin">
      <div id="roomCodeDisplay">
        <h2>Your Room Code:</h2>
        <div id="roomCode"></div>
      </div>
      <form id="roomJoinForm">
        <label for="roomCodeInput">Type it in, or join another room:</label>
        <input id="roomCodeInput" type="text" maxlength="4" pattern="[A-Za-z]{4}" placeholder="ABCD">
        <button type="submit">Join Room</button>
      </form>
    </div>

    <div id="mainMenu" class="hidden">
      <div id="langPicker">
        <label><input type="radio" name="lang" value="en" checked> English</label>
        <label><input type="radio" name="lang" value="gr"> Greek</label>
      </div>
      <button id="btnWord">Get Word</button>
      <button id="btnClue">Type Clue</button>
    </div>

    <div id="wordDisplay" class="hidden">
      <div id="wordText" class="fullscreenView">
        <span id="wordInner"></span>
      </div>
    </div>

    <div id="clueInput" class="hidden">
      <form id="clueForm" autocomplete="off">
        <div class="input-container">
          <input id="clueField" type="text" maxlength="30" placeholder="Enter one-word clue" pattern="\S+" required>
          <button type="submit" id="submitBtn">‚Üí</button>
        </div>
      </form>
    </div>

    <div id="clueDisplay" class="hidden">
      <div id="clueText" class="fullscreenView">
        <span id="clueInner"></span>
      </div>
    </div>

    <div id="wordsList" class="hidden">
      <div id="wordsListHeader">
        <h2>Words Submitted</h2>
        <div id="currentWord"></div>
      </div>
      <div id="wordsGrid"></div>
      <button id="newGameBtn">Get New Word</button>
    </div>

    <button id="backBtn" class="hidden">‚Üê</button>
    <button id="fsBtn" title="Toggle Fullscreen">‚õ∂</button>
    <div id="roomCodeBadge" class="hidden"></div
  </div>

  <script>
    // Dynamic text scaling function (FitText.js-like)
    function fitText(element, minFontSize = 20, maxFontSize = 300) {
      if (!element || !element.textContent.trim()) return;
      
      const container = element.parentElement;
      const containerWidth = container.clientWidth * 0.9;
      const containerHeight = container.clientHeight * 0.9;
      
      let fontSize = minFontSize;
      element.style.fontSize = fontSize + 'px';
      element.style.whiteSpace = 'nowrap';
      
      // Binary search for optimal font size
      let low = minFontSize;
      let high = maxFontSize;
      
      while (low <= high) {
        fontSize = Math.floor((low + high) / 2);
        element.style.fontSize = fontSize + 'px';
        
        if (element.scrollWidth <= containerWidth && element.scrollHeight <= containerHeight) {
          low = fontSize + 1;
        } else {
          high = fontSize - 1;
        }
      }
      
      element.style.fontSize = high + 'px';
    }

    const englishWords=["Accent", "Acorn", "Aladdin", "Alarm", "Alcatraz", "Alcohol", "Alien", "Alliance", "Amazon", "America", "Anchor", "Angel", "Anniversary", "Antarctica", "Apple", "Armstrong", "Australia", "Avatar", "Baby", "Baker", "Bald", "Ball", "Ballet", "Banana", "Band", "Bar", "Barbecue", "Barbie", "Bath", "Batman", "Battery", "Beer", "Belgium", "Bellybutton", "Belt", "Berry", "Bet", "Binoculars", "Blond", "Board", "Bone", "Bonfire", "Book", "Boss", "Bottle", "Bow", "Bowling", "Boxing", "Bracelet", "Brain", "Branch", "Bread", "Bridge", "Brush", "Bubble", "Buffy", "Burrito", "Butterfly", "Button", "Cactus", "Caesar", "Cafeteria", "Cake", "Calendar", "Canada", "Candy", "Cane", "Cannon", "Canteen", "Canvas", "Carnival", "Carousel", "Carpet", "Carton", "Cartoon", "Casino", "Castle", "Cat", "Caterpillar", "Cave", "Cavity", "Cell", "Cemetery", "Cereal", "Chain", "Champagne", "Cheddar", "Cheese", "Chewbacca", "Chicken", "Chile", "Chip", "Chocolate", "Christmas", "Churchill", "Cigarette", "Cinderella", "Cinema", "Circus", "Cleopatra", "Climb", "Clover", "Club", "Cockroach", "Cocktail", "Cocoon", "Coffee", "Colonel", "Comedy", "Comforter", "Computer", "Concert", "Cookie", "Cork", "Corner", "Cougar", "Crane", "Crepe", "Crocodile", "Croissant", "Cross", "Crossroads", "Crown", "Cube", "Cup", "Cupid", "Cycle", "Dance", "Darwin", "Decathlon", "Defense", "Dentist", "Desert", "Devil", "Diamond", "Dinosaur", "Disco", "Doctor", "Doll", "Doping", "Dracula", "Drag", "Dream", "Dune", "Dwarf", "Easter", "Egg", "Elastic", "Election", "Electricity", "Elephant", "Elf", "Elvis", "Emergency", "Emperor", "End", "Evening", "Everest", "Explosion", "Facebook", "Failure", "Fair", "Fairy", "Fall", "Farm", "Fashion", "Fever", "Fire", "Firecracker", "Fireman", "Fitzgerald", "Flame", "Flash", "Flight", "Flintstone", "Flower", "Flute", "Foam", "Ford", "Forest", "Fork", "Fountain", "Fox", "France", "Frankenstein", "Friday", "Fries", "Frost", "Fur", "Galaxy", "Game", "Gandhi", "Garden", "Garlic", "Genius", "Ghost", "Giant", "Gladiator", "Glass", "Glasses", "Goal", "Godfather", "Godzilla", "Golf", "Google", "Gothic", "Grass", "Greece", "Gremlins", "Grenade", "Grotto", "Guard", "Guillotine", "Gumbo", "Hair", "Hairdresser", "Halloween", "Hammer", "Handle", "Hanukkah", "Hat", "Hazelnut", "Heart", "Heel", "Helicopter", "Helmet", "History", "Hockey", "Hole", "Hollywood", "Honey", "Hose", "Hotel", "House", "Hulk", "Human", "Humor", "Hunter", "Ice", "Ikea", "Iris", "Iron", "Island", "Israel", "Italy", "Jackson", "Jedi", "Jewelry", "Joker", "Jones", "Jungle", "Karate", "King", "Knife", "Knight", "Ladder", "Ladybug", "Lake", "Lamp", "Language", "Large", "Lava", "Lawyer", "Leaf", "Leap", "Lego", "Letter", "Light", "Lightbulb", "Lighthouse", "Lightning", "Limb", "Lion", "Lonely", "Lottery", "Machine", "Mad", "Mafia", "Magician", "Magnet", "Manual", "Manure", "Map", "Mario", "Market", "Marriage", "Mars", "Mask", "Matrix", "Melon", "Metal", "Mexico", "Mickey", "Microsoft", "Milk", "Mill", "Mirage", "Mirror", "Missile", "Monkey", "Monopoly", "Moon", "Moscow", "Mosquito", "Mountain", "Mouse", "Mouth", "Mower", "Mozart", "Mummy", "Muse", "Mushroom", "Music", "Musketeer", "Mustache", "Mustard", "Myth", "Nail", "Necklace", "Needle", "Neighborhood", "Nest", "New", "Newspaper", "Nile", "Ninja", "Nintendo", "Noodle", "Nuclear", "Number", "Nun", "Oasis", "Octopus", "Olympics", "Opera", "Operation", "Oprah", "Orange", "Oven", "Painting", "Pair", "Palace", "Pan", "Panda", "Parachute", "Paradise", "Parrot", "Passion", "Peace", "Peach", "Peanut", "Pear", "Pebble", "Penguin", "Pepper", "Perfume", "Picasso", "Pie", "Pig", "Pigeon", "Pikachu", "Pillow", "Pilot", "Pimento", "Pipe", "Pirate", "Pit", "Pizza", "Plane", "Plastic", "Playstation", "Plier", "Poison", "Poker", "Polar", "Pole", "Police", "Pony", "Pool", "Pope", "Porcelain", "Potato", "Potter", "Powder", "Pregnant", "President", "Primary", "Princess", "Prison", "Prom", "Psycho", "Pump", "Punk", "Puppet", "Purse", "Pyramid", "Radio", "Rail", "Rain", "Rake", "Ram", "Rambo", "Ramses", "Rap", "Rat", "Ray", "Reggae", "Register", "Revolution", "Ring", "Ripe", "River", "Robot", "Rock", "Rocky", "Room", "Rooster", "Root", "Rope", "Rose", "Ruler", "Rum", "Safari", "Safe", "Sahara", "Sail", "Salt", "Sand", "Sausage", "Scale", "Scene", "School", "Screw", "Series", "Sewer", "Shack", "Shakespeare", "Shark", "Sheep", "Shelf", "Shell", "Sherlock", "Ship", "Shovel", "Shower", "Shrek", "Shrimp", "Simpson", "Siren", "Ski", "Sleeve", "Slipper", "Smoke", "Snake", "Snow", "Soap", "Sock", "Socket", "Sofa", "Sombrero", "Song", "Spartacus", "Spear", "Spice", "Spielberg", "Spy", "Stallion", "Star", "Starbucks", "Stark", "Station", "Stew", "Sting", "Stone", "Straw", "Strawberry", "String", "Study", "Stuffing", "Subway", "Sugar", "Sun", "Switzerland", "Sword", "Syrup", "Tango", "Tarantino", "Tarzan", "Tattoo", "Taxi", "Temple", "Tennis", "Terminator", "Theater", "Thought", "Thread", "Throat", "Thunder", "Ticket", "Tie", "Tiger", "Titanic", "Tobacco", "Tokyo", "Tolkien", "Tomato", "Tool", "Tornado", "Towel", "Tower", "Tradition", "Train", "Treasure", "Triangle", "Troy", "Truce", "Tube", "Tulip", "Tuna", "Tunnel", "Umbrella", "Unicorn", "Uniform", "Vacation", "Vampire", "Vegas", "Vegetable", "Vengeance", "Venus", "Viking", "Violin", "Virus", "Volcano", "Waltz", "War", "Watch", "Wave", "Weather", "Western", "Wheat", "White", "Widowmaker", "Wind", "Window", "Wine", "Wolf", "Yellow", "Zeus", "Zombie", "Zoo"];
    
    const greekWords=[
      "ŒµŒªŒ≠œÜŒ±ŒΩœÑŒ±œÇ","œÖœÄŒøŒªŒøŒ≥ŒπœÉœÑŒÆœÇ","ŒµœÖœÑœÖœáŒØŒ±","Œ∏Œ¨ŒªŒ±œÉœÉŒ±","œÄŒµœÑŒ±ŒªŒøœçŒ¥Œ±","Œ≤ŒøœÖŒΩœå",
      "œÜŒπŒªŒØŒ±","ŒøœÖœÅŒ¨ŒΩŒπŒø œÑœåŒæŒø","Œ∫ŒπŒ∏Œ¨œÅŒ±","œÄŒØœÑœÉŒ±","Œ∑œÜŒ±ŒØœÉœÑŒµŒπŒø","Œ¥ŒπŒ±ŒºŒ¨ŒΩœÑŒπ","Œ¥Œ¨œÉŒøœÇ",
      "Œ∫Œ¨œÉœÑœÅŒø","Œ¥ŒπŒ±œÉœÑŒ∑ŒºœåœÄŒªŒøŒπŒø","œÄœÖœÅŒ±ŒºŒØŒ¥Œ±","ŒΩŒ∑œÉŒØ","œàŒØŒ∏œÖœÅŒøœÇ","Œ∫Œ±œÑŒ±ŒπŒ≥ŒØŒ¥Œ±",
      "œÄœçœÅŒ±œÖŒªŒøœÇ","Œ∏Œ∑œÉŒ±œÖœÅœåœÇ","œÄŒøœÑŒ¨ŒºŒπ","Œ≥Œ±ŒªŒ±ŒæŒØŒ±œÇ","œÉŒøŒ∫ŒøŒªŒ¨œÑŒ±","Œ≠œÅŒ∑ŒºŒøœÇ",
      "œÉœÖŒºœÜœâŒΩŒØŒ±","Œ≥œÅŒØœÜŒøœÇ","Œ∫Œ±Œ∏œÅŒ≠œÜœÑŒ∑œÇ","Œ∂ŒøœçŒ≥Œ∫ŒªŒ±","Œ∫Œ¨ŒºŒµœÅŒ±","Œ¥œÅŒ¨Œ∫ŒøœÇ","Œ≤ŒπŒ≤ŒªŒπŒøŒ∏ŒÆŒ∫Œ∑",
      "œÑœÉŒØœÅŒ∫Œø","œÄŒ±œÅŒ¨Œ¥ŒµŒπœÉŒøœÇ","œÄœÖœÅŒøœÑŒµœáŒΩŒÆŒºŒ±œÑŒ±","œÉŒ±œÜŒ¨œÅŒπ","ŒºŒøŒΩœåŒ∫ŒµœÅŒøœÇ","ŒªŒ±Œ≤œçœÅŒπŒΩŒ∏ŒøœÇ",
      "œÜŒµœÉœÑŒπŒ≤Œ¨Œª","Œ±ŒΩŒµŒºŒøœÉœÑœÅœåŒ≤ŒπŒªŒøœÇ","œÜŒ±ŒΩŒ¨œÅŒπ","ŒºœÖœÉœÑŒÆœÅŒπŒø","Œ∫Œ±œÅŒøœÖŒ∂Œ≠Œª","Œ∫Œ±œÅœçŒ¥Œ±",
      "œÄŒ±Œ≥œåŒ≤ŒøœÖŒΩŒø","œÄœÖŒæŒØŒ¥Œ±","ŒøœÅœáŒπŒ¥Œ≠Œ±","Œ±ŒΩŒ±œÑŒøŒªŒÆ","œÑŒ∑ŒªŒµœÉŒ∫œåœÄŒπŒø","œÉŒøŒ¥ŒµŒπŒ¨"
    ];

    const roomJoin = document.getElementById('roomJoin');
    const mainMenu = document.getElementById('mainMenu');
    const wordDisplay = document.getElementById('wordDisplay');
    const clueInput = document.getElementById('clueInput');
    const clueDisplay = document.getElementById('clueDisplay');
    const wordsList = document.getElementById('wordsList');
    const backBtn = document.getElementById('backBtn');
    const fsBtn = document.getElementById('fsBtn');
    const wordInner = document.getElementById('wordInner');
    const clueInner = document.getElementById('clueInner');
    const clueField = document.getElementById('clueField');
    const roomCodeEl = document.getElementById('roomCode');
    const roomCodeInput = document.getElementById('roomCodeInput');
    const wordsGrid = document.getElementById('wordsGrid');
    const currentWordEl = document.getElementById('currentWord');
    const roomCodeBadge = document.getElementById('roomCodeBadge');
    
    let currentWord = '';
    let currentView = 'roomJoin';
    let currentLang = 'en';
    let countdownId = null;
    let wordBlurred = false;
    let wordRevealed = false;
    let roomCode = '';
    let submittedWords = [];
    let myWord = '';
    let eventSource = null;

    // Language picker
    document.querySelectorAll('[name="lang"]').forEach(radio => {
      radio.addEventListener('change', e => {
        currentLang = e.target.value;
      });
    });

    // Generate random 4-letter code
    function generateRoomCode() {
      const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      let code = '';
      for (let i = 0; i < 4; i++) {
        code += letters.charAt(Math.floor(Math.random() * letters.length));
      }
      return code;
    }

    // Initialize room
    function initRoom() {
      roomCode = generateRoomCode();
      roomCodeEl.textContent = roomCode;
    }

    // Connect to Gweet stream
    async function connectToGweet() {
      if (eventSource) {
        eventSource.abort();
      }

      const channelKey = `justone-stavros-${roomCode.toLowerCase()}`;
      
      // First get any existing messages
      try {
        const response = await fetch(`https://gweet.stavros.io/stream/${channelKey}/?latest=10`);
        const data = await response.json();
        if (data.messages && Array.isArray(data.messages)) {
          data.messages.forEach(msg => {
            if (msg.values) {
              handleGweetMessage(msg.values);
            }
          });
        }
      } catch (error) {
        console.error('Error fetching existing messages:', error);
      }
      
      // Then connect to streaming endpoint using fetch with streaming support
      const url = `https://gweet.stavros.io/stream/${channelKey}/?streaming=1`;
      eventSource = new AbortController();
      
      try {
        const response = await fetch(url, {
          signal: eventSource.signal
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        
        while (true) {
          const { done, value } = await reader.read();
          
          if (done) break;
          
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          
          // Keep the last incomplete line in the buffer
          buffer = lines.pop() || '';
          
          // Process complete lines
          for (const line of lines) {
            if (line.trim()) {
              try {
                // Parse each line as JSON
                const message = JSON.parse(line);
                if (message.values) {
                  handleGweetMessage(message.values);
                } else {
                  handleGweetMessage(line);
                }
              } catch (e) {
                // If not JSON, pass as-is
                handleGweetMessage(line);
              }
            }
          }
        }
      } catch (error) {
        if (error.name !== 'AbortError') {
          console.error('Gweet connection error:', error);
          // Attempt to reconnect after 5 seconds
          setTimeout(() => {
            if (roomCode) {
              connectToGweet();
            }
          }, 5000);
        }
      }
    }

    // Send message to Gweet
    async function sendToGweet(message) {
      const channelKey = `justone-stavros-${roomCode.toLowerCase()}`;
      const url = `https://gweet.stavros.io/stream/${channelKey}/`;
      
      try {
        await fetch(url, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
          },
          body: new URLSearchParams(message)
        });
      } catch (error) {
        console.error('Error sending to Gweet:', error);
      }
    }

    // Handle incoming Gweet messages
    function handleGweetMessage(data) {
      try {
        console.log('Received Gweet message:', data);
        
        let type, word, lang;
        
        // Check if data is already a values object from Gweet API
        if (typeof data === 'object' && !Array.isArray(data)) {
          // Extract from values object format: { type: ["newGame"], word: ["Fall"], lang: ["en"] }
          type = data.type?.[0];
          word = data.word?.[0];
          lang = data.lang?.[0];
        } else if (typeof data === 'string') {
          // Try to parse as JSON first (for streaming messages)
          try {
            const jsonData = JSON.parse(data);
            if (jsonData.values) {
              type = jsonData.values.type?.[0];
              word = jsonData.values.word?.[0];
              lang = jsonData.values.lang?.[0];
            } else if (jsonData.type) {
              // Direct object format
              type = jsonData.type;
              word = jsonData.word;
              lang = jsonData.lang;
            }
          } catch (e) {
            // Not JSON, try URL-encoded format
            const params = new URLSearchParams(data);
            type = params.get('type');
            word = params.get('word');
            lang = params.get('lang');
          }
        }
        
        if (type === 'newGame' && word) {
          currentWord = word;
          currentLang = lang || 'en';
          submittedWords = [];
          myWord = '';
          updateWordsList();
          console.log('New game started with word:', currentWord);
          if (currentView === 'wordsList') {
            currentWordEl.textContent = `Current word: ${currentWord}`;
          }
        } else if (type === 'submitWord' && word) {
          if (!submittedWords.includes(word)) {
            submittedWords.push(word);
            updateWordsList();
            console.log('Word submitted:', word);
          }
        }
      } catch (error) {
        console.error('Error handling Gweet message:', error, 'Data:', data);
      }
    }

    // Update words list display
    function updateWordsList() {
      wordsGrid.innerHTML = '';
      submittedWords.forEach(word => {
        const wordEl = document.createElement('div');
        wordEl.className = 'wordItem';
        if (word === myWord) {
          wordEl.classList.add('own');
        }
        wordEl.textContent = word;
        wordEl.onclick = () => showWordFullscreen(word);
        wordsGrid.appendChild(wordEl);
      });
    }

    // Show word in fullscreen
    function showWordFullscreen(word) {
      clueInner.textContent = word;
      show('clue');
      enterFullscreen();
      fitText(clueInner);
      setTimeout(() => fitText(clueInner), 100);
    }

    // View management
    function show(view) {
      [roomJoin, mainMenu, wordDisplay, clueInput, clueDisplay, wordsList].forEach(v => v.classList.add('hidden'));
      
      if (view === 'roomJoin') {
        backBtn.classList.add('hidden');
        roomCodeBadge.classList.add('hidden');
      } else if (view === 'menu') {
        backBtn.classList.add('hidden');
        roomCodeBadge.classList.remove('hidden');
        roomCodeBadge.textContent = `Room: ${roomCode}`;
      } else {
        backBtn.classList.remove('hidden');
        roomCodeBadge.classList.remove('hidden');
        roomCodeBadge.textContent = `Room: ${roomCode}`;
      }
      
      switch(view) {
        case 'roomJoin': roomJoin.classList.remove('hidden'); break;
        case 'menu': mainMenu.classList.remove('hidden'); break;
        case 'word': wordDisplay.classList.remove('hidden'); break;
        case 'clueIn': clueInput.classList.remove('hidden'); break;
        case 'clue': clueDisplay.classList.remove('hidden'); break;
        case 'wordsList': 
          wordsList.classList.remove('hidden');
          currentWordEl.textContent = currentWord ? `Current word: ${currentWord}` : 'No word selected yet';
          updateWordsList();
          break;
      }
      currentView = view;
      
      // Update browser history for back button handling
      if (view !== 'menu' && view !== 'roomJoin') {
        history.pushState({ view: view }, '', '#' + view);
      } else {
        history.replaceState({ view: view }, '', window.location.pathname);
      }
    }

    // Auto fullscreen helper
    function enterFullscreen() {
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
      if (!isIOS && document.documentElement.requestFullscreen && !document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(() => {});
      }
    }

    // Room join form
    document.getElementById('roomJoinForm').addEventListener('submit', (e) => {
      e.preventDefault();
      const inputCode = roomCodeInput.value.trim().toUpperCase();
      if (inputCode && /^[A-Z]{4}$/.test(inputCode)) {
        roomCode = inputCode;
        connectToGweet();
        show('menu');
      } else if (!inputCode) {
        // Use generated code
        connectToGweet();
        show('menu');
      }
    });

    // Get Word button
    document.getElementById('btnWord').onclick = async () => {
      const pool = currentLang === 'en' ? englishWords : greekWords;
      currentWord = pool[Math.floor(Math.random() * pool.length)];
      
      // Reset words and notify other players
      submittedWords = [];
      myWord = '';
      await sendToGweet({
        type: 'newGame',
        word: currentWord,
        lang: currentLang
      });

      show('word');
      enterFullscreen(); // Auto enter fullscreen

      let seconds = 2;
      wordInner.textContent = seconds;
      fitText(wordInner);
      wordRevealed = false;
      wordBlurred = false;

      if (countdownId) clearInterval(countdownId);
      countdownId = setInterval(() => {
        seconds--;
        if (seconds <= 0) {
          clearInterval(countdownId);
          countdownId = null;
          wordInner.textContent = currentWord;
          wordRevealed = true;
        } else {
          wordInner.textContent = seconds;
        }
        fitText(wordInner);
      }, 1000);
    };

    // Word screen tap-to-blur functionality
    const wordText = document.getElementById('wordText');
    wordText.addEventListener('click', () => {
      if (currentView === 'word' && wordRevealed) {
        wordBlurred = !wordBlurred;
        if (wordBlurred) {
          wordInner.classList.add('blurred');
          wordText.classList.add('word-blurred');
        } else {
          wordInner.classList.remove('blurred');
          wordText.classList.remove('word-blurred');
        }
        
        // Haptic feedback
        if (navigator.vibrate) {
          navigator.vibrate(50); // Vibrate for 50ms
        }
      }
    });

    // New game button in words list
    document.getElementById('newGameBtn').onclick = async () => {
      const pool = currentLang === 'en' ? englishWords : greekWords;
      currentWord = pool[Math.floor(Math.random() * pool.length)];
      
      // Reset words and notify other players
      submittedWords = [];
      myWord = '';
      await sendToGweet({
        type: 'newGame',
        word: currentWord,
        lang: currentLang
      });
      
      currentWordEl.textContent = `Current word: ${currentWord}`;
      updateWordsList();
      
      alert('New word selected! All players have been notified.');
    };

    // Allow only letters in clue field (any language)
    clueField.addEventListener('keydown', (e) => {
      // Allow: backspace, delete, tab, escape, enter, arrow keys
      if ([8, 9, 27, 13, 37, 38, 39, 40, 46].includes(e.keyCode) ||
          // Allow Ctrl+A, Ctrl+C, Ctrl+V, Ctrl+X, Ctrl+Z, Cmd+A, Cmd+C, Cmd+V, Cmd+X, Cmd+Z
          (e.ctrlKey === true && [65, 67, 86, 88, 90].includes(e.keyCode)) ||
          (e.metaKey === true && [65, 67, 86, 88, 90].includes(e.keyCode))) {
        return;
      }
      
      // For non-ASCII characters, let the input event handle the filtering
      if (e.keyCode > 127) {
        return;
      }
      
      // Prevent if not a letter (for ASCII characters)
      const char = String.fromCharCode(e.keyCode);
      if (!/^[a-zA-Z]$/.test(char)) {
        e.preventDefault();
      }
    });
    
    clueField.addEventListener('input', (e) => {
      // Remove any non-letter characters (supports all Unicode letters)
      e.target.value = e.target.value.replace(/[^\p{L}]/gu, '');
    });

    // Type Clue button - shows word submission input
    document.getElementById('btnClue').onclick = () => {
      if (!currentWord) {
        alert('No word has been selected yet. Someone needs to get a word first!');
        return;
      }
      clueField.value = '';
      show('clueIn');
      setTimeout(() => clueField.focus(), 10);
    };

    // Clue form submission - now submits to Gweet
    document.getElementById('clueForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const val = clueField.value.trim();
      if (!val) return;
      if (/\s/.test(val)) { alert('One word only!'); return; }
      
      myWord = val;
      await sendToGweet({
        type: 'submitWord',
        word: val
      });
      
      // Add to local list immediately
      if (!submittedWords.includes(val)) {
        submittedWords.push(val);
      }
      
      show('wordsList');
    });

    // Handle browser back button/gesture
    function goBackToMenu(skipConfirmation = false) {
      if (!skipConfirmation && currentView !== 'menu' && currentView !== 'roomJoin') {
        let confirmMessage = 'Go back to main menu?';
        
        if (currentView === 'word') {
          confirmMessage = 'Leave and lose the word?';
        } else if (currentView === 'clueIn') {
          confirmMessage = 'Cancel word input?';
        } else if (currentView === 'clue') {
          confirmMessage = 'Leave word display?';
        } else if (currentView === 'wordsList') {
          confirmMessage = 'Go back to main menu?';
        }
        
        if (!confirm(confirmMessage)) {
          // User cancelled, push the current state back to prevent navigation
          history.pushState({ view: currentView }, '', '#' + currentView);
          return;
        }
      }
      
      if (countdownId) { 
        clearInterval(countdownId); 
        countdownId = null; 
      }
      
      if (currentView === 'word') {
        currentWord = '';
        // Reset blur state
        wordBlurred = false;
        wordRevealed = false;
        wordInner.classList.remove('blurred');
        document.getElementById('wordText').classList.remove('word-blurred');
      }
      show('menu');
    }

    // Back button
    backBtn.onclick = () => {
      goBackToMenu();
    };

    // Handle browser back button/swipe navigation
    window.addEventListener('popstate', (event) => {
      // Show confirmation for word screen, always go back for other screens
      goBackToMenu();
    });

    // Event listeners for dynamic resizing
    window.addEventListener('resize', () => {
      if (currentView === 'word') fitText(wordInner);
      if (currentView === 'clue') fitText(clueInner);
    });
    
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        if (currentView === 'word') fitText(wordInner);
        if (currentView === 'clue') fitText(clueInner);
      }, 100);
    });

    // Fullscreen functionality
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
    
    if (!document.documentElement.requestFullscreen || isIOS) {
      fsBtn.style.display = 'none';
    } else {
      function updateFSIcon() {
        fsBtn.textContent = document.fullscreenElement ? 'üóó' : '‚õ∂';
      }
      fsBtn.addEventListener('click', () => {
        if (document.fullscreenElement) {
          document.exitFullscreen?.();
        } else {
          document.documentElement.requestFullscreen().catch(() => {});
        }
      });
      document.addEventListener('fullscreenchange', updateFSIcon);
      updateFSIcon();
    }

    // Initialize room on load
    initRoom();
  </script>
</body>
</html>
